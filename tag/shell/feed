<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>wklken's blog</title><link>http://www.wklken.me/</link><description></description><atom:link href="http://www.wklken.me/tag/shell/feed" rel="self"></atom:link><lastBuildDate>Thu, 04 Jul 2013 00:00:00 +0800</lastBuildDate><item><title>Linux Shell脚本攻略笔记[速查]</title><link>http://www.wklken.me/posts/2013/07/04/note-of-linux-shell-scripting-cookbook.html</link><description>&lt;p&gt;Linux Shell脚本攻略的笔记，markdown编写，可以速查(ctrl+f)&lt;/p&gt;
&lt;p&gt;2013-09-08 从历史网摘中补充
 2014-02-16 增加&amp;lt;&lt;shell脚本指南&gt;&amp;gt;笔记补充&lt;/p&gt;
&lt;hr /&gt;
&lt;h3&gt;资源&lt;/h3&gt;
&lt;p&gt;&lt;a href="http://coolshell.cn/articles/9104.html"&gt;sed简明教程&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://coolshell.cn/articles/9070.html"&gt;awk简明教程&lt;/a&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;h3&gt;shell script&lt;/h3&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="c"&gt;#!/bin/bash&lt;/span&gt;
&lt;span class="c"&gt;# do something&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;run shell script&lt;/h3&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;sh script.sh

or

chmod a+x script.sh
./script.sh
# 会读取首行的解释器, 执行
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;cmd&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;cmd1; cmd2

or

cmd1
cmd2
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;echo&lt;/h3&gt;
&lt;p&gt;echo  的功能正如其名，就是基于标准输出打印一段文本&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;echo &amp;quot;welcome to bash&amp;quot;
echo welcome to bash
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;使用不带引号的echo时，无法显示分号&lt;/p&gt;
&lt;p&gt;使用单引号echo时，bash不会对单引号中变量求值  '$var'&lt;/p&gt;
&lt;p&gt;echo 中转义换行符&lt;/p&gt;
&lt;p&gt;默认情况，echo将换行标志追加到文本尾部，可以忽略结尾换行符&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;echo -n &amp;#39;test\n&amp;#39;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;对字符串进行转义&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;echo -e &amp;#39;1\t2\t3&amp;#39;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;打印彩色输出&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;文字颜色码
    重置0
    黑色30
    红色31
    绿色32
    黄色33
    蓝色34
    洋红35
    青色36
    白色37

echo -e &amp;quot;\e[1;31m This is red test \e[0m&amp;quot;

背景颜色码
    重置0
    黑色40
    红色41
    绿色42
    黄色43
    蓝色44
    洋红45
    青色46
    白色47

echo -e &amp;quot;\e[1;42m Green Background \e[0m&amp;quot;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;printf&lt;/h3&gt;
&lt;p&gt;可以格式化字符串, 使用参数同c中printf一样&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;printf &amp;quot;hello world&amp;quot;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;默认不会加换行符, 需要手动添加&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;printf &amp;quot;%-5s %-10s %-4.2f\n&amp;quot; 3 Jeff 77.564

3    Jeff      77.56
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;环境变量和变量&lt;/h3&gt;
&lt;p&gt;bash中，每个变量的值都是字符串，无论你给变量赋值时是否使用引号，值都会以字符串的形式存储&lt;/p&gt;
&lt;p&gt;环境变量&lt;/p&gt;
&lt;p&gt;查看所有与此终端进程相关的环境变量&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;env
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;查看某个进程的环境变量&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="x"&gt;cat /proc/&lt;/span&gt;&lt;span class="p"&gt;$&lt;/span&gt;&lt;span class="nv"&gt;PID&lt;/span&gt;&lt;span class="x"&gt;/environ&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;变量赋值&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;var=value
var=&amp;#39;the value&amp;#39;
var=&amp;quot;the &lt;span class="nv"&gt;$PARAM&lt;/span&gt;&amp;quot;

echo &lt;span class="nv"&gt;$var&lt;/span&gt;
echo &lt;span class="cp"&gt;${&lt;/span&gt;&lt;span class="n"&gt;var&lt;/span&gt;&lt;span class="cp"&gt;}&lt;/span&gt;

var = value非变量赋值是相等操作
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;环境变量&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="x"&gt;未在当前进程中定义，而是从父进程中继承而来的变量&lt;/span&gt;
&lt;span class="x"&gt;export 设置环境变量,之后,从当前shell 执行的任何程序都会继承这个变量&lt;/span&gt;

&lt;span class="x"&gt;export PYTHONPATH=&lt;/span&gt;&lt;span class="p"&gt;$&lt;/span&gt;&lt;span class="nv"&gt;PYTHONPATH&lt;/span&gt;&lt;span class="x"&gt;:/home/ken/workspace&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;常用的环境变量&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="x"&gt;PATH 查找可执行文件路径, 通常定义在/etc/environment or /ect/profile or ~/.bashrc&lt;/span&gt;
&lt;span class="x"&gt;修改:        export PATH=&lt;/span&gt;&lt;span class="p"&gt;$&lt;/span&gt;&lt;span class="nv"&gt;PATH&lt;/span&gt;&lt;span class="x"&gt;:/new/path/&lt;/span&gt;
&lt;span class="x"&gt;HOME&lt;/span&gt;
&lt;span class="x"&gt;PWD&lt;/span&gt;
&lt;span class="x"&gt;USER&lt;/span&gt;
&lt;span class="x"&gt;UID&lt;/span&gt;
&lt;span class="x"&gt;SHELL&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;获取字符串长度&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;length=&lt;span class="cp"&gt;${&lt;/span&gt;&lt;span class="c"&gt;#var&lt;/span&gt;&lt;span class="cp"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;识别当前shell版本&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="x"&gt;echo &lt;/span&gt;&lt;span class="p"&gt;$&lt;/span&gt;&lt;span class="nv"&gt;SHELL&lt;/span&gt;&lt;span class="x"&gt;&lt;/span&gt;
&lt;span class="x"&gt;    /bin/bash&lt;/span&gt;
&lt;span class="x"&gt;echo &lt;/span&gt;&lt;span class="p"&gt;$&lt;/span&gt;&lt;span class="x"&gt;0&lt;/span&gt;
&lt;span class="x"&gt;    bash&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;检查是否为超级用户 or 普通用户&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="x"&gt;root的UID=0&lt;/span&gt;

&lt;span class="x"&gt;if [ &lt;/span&gt;&lt;span class="p"&gt;$&lt;/span&gt;&lt;span class="nv"&gt;UID&lt;/span&gt;&lt;span class="x"&gt; -ne 0 ]&lt;/span&gt;
&lt;span class="x"&gt;then&lt;/span&gt;
&lt;span class="x"&gt;    echo &amp;quot;not root user&amp;quot;&lt;/span&gt;
&lt;span class="x"&gt;else&lt;/span&gt;
&lt;span class="x"&gt;    echo &amp;quot;root&amp;quot;&lt;/span&gt;
&lt;span class="x"&gt;fi&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;修改bash的提示字符&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;设置PS1变量
\u用户名
\h主机名
\w当前工作目录
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;pgrep&lt;/h3&gt;
&lt;p&gt;获取某个进程名对应进程id&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;pgrep gedit
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;shell数学运算&lt;/h3&gt;
&lt;p&gt;整数运算&lt;/p&gt;
&lt;p&gt;let&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;no1=4
no2=5
let result=no1+no2

let no1++
let no2--
let no1+=7
let no2-=7
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;expr(少用)&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="x"&gt;result=`expr 3 + 4`&lt;/span&gt;
&lt;span class="x"&gt;result=&lt;/span&gt;&lt;span class="p"&gt;$(&lt;/span&gt;&lt;span class="err"&gt;expr&lt;/span&gt; &lt;span class="p"&gt;$&lt;/span&gt;&lt;span class="nv"&gt;no1&lt;/span&gt; &lt;span class="err"&gt;+&lt;/span&gt; &lt;span class="m"&gt;5&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="x"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;其他方法&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="x"&gt;result=&lt;/span&gt;&lt;span class="p"&gt;$&lt;/span&gt;&lt;span class="x"&gt;[ no1 + no2 ]&lt;/span&gt;
&lt;span class="x"&gt;result=&lt;/span&gt;&lt;span class="p"&gt;$&lt;/span&gt;&lt;span class="x"&gt;[ &lt;/span&gt;&lt;span class="p"&gt;$&lt;/span&gt;&lt;span class="nv"&gt;no&lt;/span&gt;&lt;span class="x"&gt; + 5 ]&lt;/span&gt;

&lt;span class="x"&gt;result=&lt;/span&gt;&lt;span class="p"&gt;$((&lt;/span&gt; &lt;span class="err"&gt;no1&lt;/span&gt; &lt;span class="err"&gt;+&lt;/span&gt; &lt;span class="m"&gt;5&lt;/span&gt; &lt;span class="p"&gt;))&lt;/span&gt;&lt;span class="x"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;浮点数&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;echo &amp;quot;4 * 0.56&amp;quot; | bc
设定精度
echo &amp;quot;scale=2;3/8&amp;quot; | bc
进制转换
echo &amp;quot;obase=2;100&amp;quot; | bc
平方
echo &amp;quot;10^10&amp;quot; | bc
平方根
echo &amp;quot;sqrt(100)&amp;quot; | bc
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;命令状态&lt;/h3&gt;
&lt;p&gt;当命令成功完成, 返回0&lt;/p&gt;
&lt;p&gt;发生错误并退回, 返回非0&lt;/p&gt;
&lt;p&gt;可以从$?中获取  cmd; echo $?&lt;/p&gt;
&lt;h3&gt;文件描述符和重定向&lt;/h3&gt;
&lt;p&gt;文件描述符: 与文件输入/输出相关联的整数, 用来跟踪已打开的文件&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;0 stdin  标砖输入
1 stdout 标准输出
2 stderr 标准错误
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;重定向到文件&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;清空文件写入新内容
echo &amp;quot;test&amp;quot; &amp;gt; temp.txt
追加
echo &amp;quot;test&amp;quot; &amp;gt;&amp;gt; temp.txt

&amp;gt;等价于1&amp;gt;
&amp;gt;&amp;gt;等价于 1&amp;gt;&amp;gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;输出分离或合并&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;分离
cmd 2&amp;gt;stderr.txt  1&amp;gt;stdout.txt

合并
cmd &amp;gt; output.txt 2&amp;gt;&amp;amp;1
or
cmd &amp;amp;&amp;gt; output.txt
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;扔到垃圾桶&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;/dev/null 特殊设备文件, 接收到的任何数据都会被丢弃(位桶/黑洞)

只有标准错误
cmd 2 &amp;gt; /dev/null

标准输出和标准错误
cmd &amp;gt;/dev/null 2&amp;gt;&amp;amp;1
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;同时输出到终端和文件&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;cmd | tee file1

tee默认覆盖，可以-a选项追加
cmd | tee -a file1
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;将stdin作为命令参数&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;cmd1 | cmd2 | cmd3 -
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;将文件重定向到命令&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;cmd &amp;lt; file
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;自定义文件描述符&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;使用文件描述符3打开并读取文件
exec 3&lt;span class="nt"&gt;&amp;lt;input.txt&lt;/span&gt;
&lt;span class="na"&gt;cat&lt;/span&gt; &lt;span class="err"&gt;&amp;lt;&amp;amp;&lt;/span&gt;3

使用文件描述符4进行写入
exec 4&amp;gt;output.txt
echo newline &amp;gt;&lt;span class="err"&gt;&amp;amp;&lt;/span&gt;4
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;cat&lt;/h3&gt;
&lt;p&gt;cat, concatenate(拼接)&lt;/p&gt;
&lt;p&gt;“cat”代表了连结（Concatenation），连接两个或者更多文本文件或者以标准输出形式打印文件的内容&lt;/p&gt;
&lt;p&gt;一般格式&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;cat file1 file2 file3

从管道中读取
OUTPUT_FROM_SOME_CMDS | cat

echo &amp;quot;test&amp;quot; | cat - file1
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;压缩空白行, 多个连续空行变成单个&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;cat -s  file
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;配合tr移除空白行&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;cat file | tr -s &amp;#39;\n&amp;#39; #连续多个\n -&amp;gt; \n
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;加行号&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;cat -n file
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;显示制表符等&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;cat -T file

cat f &amp;gt; t
注意：“&amp;gt;&amp;gt;”和“&amp;gt;”调用了追加符号。它们用来追加到文件里，而不是显示在标准输出上。
“&amp;gt;”符号会删除已存在的文件，然后创建一个新的文件。
所以因为安全的原因，建议使用“&amp;gt;&amp;gt;”，它会写入到文件中，而不是覆盖或者删除。
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;输入多行文字(CTRL + d 退出)&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;cat &amp;gt; test.txt
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;数组和关联数组&lt;/h3&gt;
&lt;p&gt;普通数组，整数作为数组索引, 借助索引将多个独立的数据存储为一个集合(list)&lt;/p&gt;
&lt;p&gt;关联数组，可以使用字符串作为索引(map)&lt;/p&gt;
&lt;p&gt;数组&lt;/p&gt;
&lt;p&gt;定义&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;array_var=(1 2 3 4 5)

or
array_var[0]=&amp;quot;test1&amp;quot;
array_var[3]=&amp;quot;test3&amp;quot;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;读取&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;echo &lt;span class="cp"&gt;${&lt;/span&gt;&lt;span class="n"&gt;array_var&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="cp"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;以清单形式打印&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;echo &lt;span class="cp"&gt;${&lt;/span&gt;&lt;span class="n"&gt;array_var&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="cp"&gt;}&lt;/span&gt;
echo &lt;span class="cp"&gt;${&lt;/span&gt;&lt;span class="n"&gt;array_var&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="err"&gt;@&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="cp"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;长度&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;echo &lt;span class="cp"&gt;${&lt;/span&gt;&lt;span class="c"&gt;#array_var[*]&lt;/span&gt;&lt;span class="cp"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;获取索引列表&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;echo &lt;span class="cp"&gt;${&lt;/span&gt;&lt;span class="err"&gt;!&lt;/span&gt;&lt;span class="n"&gt;array_var&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="cp"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;关联数组&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;declare -A ass_array

内嵌索引-值
ass_array=([index1]=value1 [index2]=value2)

独立
ass_array[index3]=value3

echo &lt;span class="cp"&gt;${&lt;/span&gt;&lt;span class="n"&gt;ass_array&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;index1&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="cp"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;alias&lt;/h3&gt;
&lt;p&gt;alias是一个系统自建的shell命令，允许你为名字比较长的或者经常使用的命令指定别名。&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;alias new_command=&amp;#39;command seq&amp;#39;
unalias new_command

使用原生命令
\new_command
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;date&lt;/h3&gt;
&lt;p&gt;“date”命令使用标准的输出打印当前的日期和时间，也可以深入设置&lt;/p&gt;
&lt;p&gt;读取日期&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;date
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;时间戳&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;date +%s
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;日期转换为时间戳&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;date --date &amp;quot;Thu Nov 18 08:07:21 IST 2010&amp;quot; +%s
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;日期格式化&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;星期  %a  Sat
      %A  Saturday
月    %b  Nov
      %B  November
日    %d  31
固定日期格式mm/dd/yy     %D
年    %y  10
      %Y  2010
小时  %I/%H    08
分钟  %M  33
秒    %S  10
纳秒  %N  696308515
Unix纪元时  %s
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;格式化&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;date &amp;quot;+%Y %B %d&amp;quot;

date +%Y-%m-%d
输出： 2011-07-28
date +&amp;quot;%Y-%m-%d %H:%M:%S&amp;quot;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;设置日期和时间&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;date -s &amp;quot;格式化日期字符串&amp;quot;

date -s &amp;quot;21 June 2009 11:01:22&amp;quot;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;延时&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;sleep number_of_seconds
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;两天后及两天前&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;date -d &amp;#39;2 days&amp;#39; +%Y%m%d
date -d &amp;#39;2 days ago&amp;#39; +%Y%m%d
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;某一天的几天前&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="x"&gt;TODAY=`date +%Y%m%d`&lt;/span&gt;
&lt;span class="x"&gt;DAY_1_AGO=`date -d &amp;quot;&lt;/span&gt;&lt;span class="p"&gt;$&lt;/span&gt;&lt;span class="nv"&gt;TODAY&lt;/span&gt;&lt;span class="x"&gt; 1 days ago&amp;quot; +%Y%m%d`&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;时间戳日期转换&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="n"&gt;date&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;d&lt;/span&gt; &lt;span class="mi"&gt;@1193144433&lt;/span&gt;
&lt;span class="n"&gt;date&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;d&lt;/span&gt; &lt;span class="mi"&gt;@1193144433&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;+%Y-%m-%d %T&amp;quot;&lt;/span&gt;

&lt;span class="err"&gt;反向&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
&lt;span class="n"&gt;date&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;d&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;2007-10-23 15:00:23&amp;quot;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;+%s&amp;quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;赋值给变量&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;DATE=$(date +%Y%m%d)
DATE=`date +%Y%m%d`
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;调试脚本&lt;/h3&gt;
&lt;p&gt;打印出所执行的每一行命令&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;bash -x script.sh
sh -x script.sh
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;在脚本中设置开关&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;set -x 在执行时显示参数和命令
set +x 关闭调试
set -v 当命令进行读取时显示输入
set +v 禁止打印输入
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;直接修改脚本&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="c"&gt;#!/bin/bash -xv&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;函数和参数&lt;/h3&gt;
&lt;p&gt;定义函数&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="kd"&gt;function&lt;/span&gt; &lt;span class="nx"&gt;fname&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="nx"&gt;statements&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="nx"&gt;or&lt;/span&gt;
&lt;span class="nx"&gt;fname&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="nx"&gt;statements&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;调用&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;fname;
传参
fname arg1 arg2;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;接收参数&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="err"&gt;$&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="err"&gt;第一个参数&lt;/span&gt;
&lt;span class="err"&gt;$&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="err"&gt;第二个参数&lt;/span&gt;
&lt;span class="err"&gt;$&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="err"&gt;第&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="err"&gt;个参数&lt;/span&gt;

&lt;span class="s"&gt;&amp;quot;$@&amp;quot;&lt;/span&gt;&lt;span class="err"&gt;被扩展成&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;$1&amp;quot;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;$2&amp;quot;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;$3&amp;quot;&lt;/span&gt;
&lt;span class="s"&gt;&amp;quot;$*&amp;quot;&lt;/span&gt;&lt;span class="err"&gt;扩展成&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;$1c$2c$3&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="err"&gt;其中&lt;/span&gt;&lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="err"&gt;是&lt;/span&gt;&lt;span class="n"&gt;IFS&lt;/span&gt;&lt;span class="err"&gt;第一个字符&lt;/span&gt;

&lt;span class="s"&gt;&amp;quot;$@&amp;quot;&lt;/span&gt;&lt;span class="err"&gt;使用最多&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="err"&gt;$&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="err"&gt;将所有的参数当做单个字符串&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;bash支持递归&lt;/p&gt;
&lt;p&gt;导出函数,可以作用到子进程中&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;export -f fname
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;函数及命令返回值&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;cmd;
echo $?

退出状态，成功退出，状态为0，否则，非0

cmd
if [ $? -eq 0 ]
then
    echo &amp;quot;success&amp;quot;
else
    echo &amp;quot;fail&amp;quot;
fi
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;管道&lt;/h3&gt;
&lt;p&gt;前一个命令的输出作为后一个命令的输入&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="p"&gt;$&lt;/span&gt;&lt;span class="nv"&gt;cmd1&lt;/span&gt;&lt;span class="x"&gt; | cmd2 | cmd3&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;读取命令输出&lt;/h3&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="err"&gt;子shell&lt;/span&gt;  &lt;span class="err"&gt;subshell&lt;/span&gt;
&lt;span class="nv"&gt;cmd_output&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="k"&gt;$(&lt;/span&gt;COMMANDS&lt;span class="k"&gt;)&lt;/span&gt;
&lt;span class="err"&gt;or&lt;/span&gt;
&lt;span class="err"&gt;反引用&lt;/span&gt;
&lt;span class="nv"&gt;cmd_output&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="sb"&gt;`&lt;/span&gt;COMMANDS&lt;span class="sb"&gt;`&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;子shell本身是独立进程, 不会对当前shell有任何影响&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;pwd;
(cd /bin; ls)
pwd #同上一个pwd
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;保留空格和换行符&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="x"&gt;out=&lt;/span&gt;&lt;span class="p"&gt;$(&lt;/span&gt;&lt;span class="err"&gt;cat&lt;/span&gt; &lt;span class="err"&gt;text.txt&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="x"&gt;&lt;/span&gt;
&lt;span class="x"&gt;echo &lt;/span&gt;&lt;span class="p"&gt;$&lt;/span&gt;&lt;span class="nv"&gt;out&lt;/span&gt;&lt;span class="x"&gt;  &lt;/span&gt;&lt;span class="err"&gt;#&lt;/span&gt;&lt;span class="x"&gt;丢失所有换行符&lt;/span&gt;

&lt;span class="x"&gt;out=&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;$(&lt;/span&gt;&lt;span class="err"&gt;cat&lt;/span&gt; &lt;span class="err"&gt;text.txt&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="x"&gt;&amp;quot;&lt;/span&gt;
&lt;span class="x"&gt;echo &lt;/span&gt;&lt;span class="p"&gt;$&lt;/span&gt;&lt;span class="nv"&gt;out&lt;/span&gt;&lt;span class="x"&gt;  &lt;/span&gt;&lt;span class="err"&gt;#&lt;/span&gt;&lt;span class="x"&gt;保留&lt;/span&gt;

&lt;span class="x"&gt;cat a&lt;/span&gt;
&lt;span class="x"&gt;1&lt;/span&gt;
&lt;span class="x"&gt;2&lt;/span&gt;
&lt;span class="x"&gt;3&lt;/span&gt;
&lt;span class="x"&gt;echo &lt;/span&gt;&lt;span class="p"&gt;$(&lt;/span&gt;&lt;span class="err"&gt;cat&lt;/span&gt; &lt;span class="err"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="x"&gt;&lt;/span&gt;
&lt;span class="x"&gt;1 2 3&lt;/span&gt;
&lt;span class="x"&gt;echo &amp;quot;&lt;/span&gt;&lt;span class="p"&gt;$(&lt;/span&gt;&lt;span class="err"&gt;cat&lt;/span&gt; &lt;span class="err"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="x"&gt;&amp;quot;&lt;/span&gt;
&lt;span class="x"&gt;1&lt;/span&gt;
&lt;span class="x"&gt;2&lt;/span&gt;
&lt;span class="x"&gt;3&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;read&lt;/h3&gt;
&lt;p&gt;read, 用于从键盘或标准输入中读取文本&lt;/p&gt;
&lt;p&gt;读取n个字符存入变量&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;read -n number_of_chars variable_name
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;不回显的方式读取密码&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;read -s var
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;显示提示信息&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;read -p &amp;quot;Enter input:&amp;quot; var
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;限时输入&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;read -t  timeout var
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;设置界定符&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;read -d delim_char var
read -d &amp;quot;:&amp;quot; var
hello:
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;字段分隔符和迭代器&lt;/h3&gt;
&lt;p&gt;内部字段分隔符，Internal Field Separator, IFS&lt;/p&gt;
&lt;p&gt;IFS默认为空白字符（换行符，制表符，空格）&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="x"&gt;data=&amp;quot;name,sex,rollno&amp;quot;&lt;/span&gt;
&lt;span class="x"&gt;oldIFS=&lt;/span&gt;&lt;span class="p"&gt;$&lt;/span&gt;&lt;span class="nv"&gt;IFS&lt;/span&gt;&lt;span class="x"&gt;&lt;/span&gt;
&lt;span class="x"&gt;IFS=,&lt;/span&gt;
&lt;span class="x"&gt;for item in &lt;/span&gt;&lt;span class="p"&gt;$&lt;/span&gt;&lt;span class="nv"&gt;data&lt;/span&gt;&lt;span class="x"&gt;&lt;/span&gt;
&lt;span class="x"&gt;do&lt;/span&gt;
&lt;span class="x"&gt;        echo &lt;/span&gt;&lt;span class="p"&gt;$&lt;/span&gt;&lt;span class="nv"&gt;item&lt;/span&gt;&lt;span class="x"&gt;&lt;/span&gt;
&lt;span class="x"&gt;done&lt;/span&gt;

&lt;span class="x"&gt;IFS=&lt;/span&gt;&lt;span class="p"&gt;$&lt;/span&gt;&lt;span class="nv"&gt;oldIFS&lt;/span&gt;&lt;span class="x"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;循环&lt;/h3&gt;
&lt;p&gt;for循环&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;echo {1..50}

for i in {a..z}; do actions; done;

or

for((i=0;i&amp;lt;10;i++))
{
    commands;
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;while循环&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;while condition
do
    commands;
done
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;until循环&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;until condition
do
    commands;
done
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;比较和测试&lt;/h3&gt;
&lt;p&gt;if条件&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;if condition;
then
    commands;
elif condition;
then
    commands;
else
    commands;
fi
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;逻辑运算符进行简化, 短路运算更简洁&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;[ condition ] &amp;amp;&amp;amp; action;
[ condition ] || action;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;算术比较&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="x"&gt;-gt 大于&lt;/span&gt;
&lt;span class="x"&gt;-lt 小于&lt;/span&gt;
&lt;span class="x"&gt;-ge 大于等于&lt;/span&gt;
&lt;span class="x"&gt;-le 小于等于&lt;/span&gt;
&lt;span class="x"&gt;-ne 不等于&lt;/span&gt;
&lt;span class="x"&gt;-eq 等于&lt;/span&gt;

&lt;span class="x"&gt;注意[]和操作数之间的空格&lt;/span&gt;
&lt;span class="x"&gt;[ &lt;/span&gt;&lt;span class="p"&gt;$&lt;/span&gt;&lt;span class="nv"&gt;var&lt;/span&gt;&lt;span class="x"&gt; -eq 0 ]&lt;/span&gt;

&lt;span class="x"&gt;and&lt;/span&gt;
&lt;span class="x"&gt;[ &lt;/span&gt;&lt;span class="p"&gt;$&lt;/span&gt;&lt;span class="nv"&gt;var&lt;/span&gt;&lt;span class="x"&gt; -ne 0 -a &lt;/span&gt;&lt;span class="p"&gt;$&lt;/span&gt;&lt;span class="nv"&gt;var2&lt;/span&gt;&lt;span class="x"&gt; -ge 2 ]&lt;/span&gt;
&lt;span class="x"&gt;or&lt;/span&gt;
&lt;span class="x"&gt;[ &lt;/span&gt;&lt;span class="p"&gt;$&lt;/span&gt;&lt;span class="nv"&gt;var&lt;/span&gt;&lt;span class="x"&gt; -ne 0 -o &lt;/span&gt;&lt;span class="p"&gt;$&lt;/span&gt;&lt;span class="nv"&gt;var2&lt;/span&gt;&lt;span class="x"&gt; -ge 2 ]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;文件测试&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="x"&gt;[ -f &lt;/span&gt;&lt;span class="p"&gt;$&lt;/span&gt;&lt;span class="nv"&gt;file_var&lt;/span&gt;&lt;span class="x"&gt; ] 正常文件路径或文件名&lt;/span&gt;
&lt;span class="x"&gt;[ -x &lt;/span&gt;&lt;span class="p"&gt;$&lt;/span&gt;&lt;span class="nv"&gt;var&lt;/span&gt;&lt;span class="x"&gt; ] 可执行&lt;/span&gt;
&lt;span class="x"&gt;-d 目录&lt;/span&gt;
&lt;span class="x"&gt;-e 存在&lt;/span&gt;
&lt;span class="x"&gt;-c 字符设备文件&lt;/span&gt;
&lt;span class="x"&gt;-b 块设备文件&lt;/span&gt;
&lt;span class="x"&gt;-w 可写&lt;/span&gt;
&lt;span class="x"&gt;-r 可读&lt;/span&gt;
&lt;span class="x"&gt;-L 符号链接&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;字符串比较&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="k"&gt;[[ $str1 = $str2 ]]&lt;/span&gt;
&lt;span class="k"&gt;[[ $str1 == $str2 ]]&lt;/span&gt;

&lt;span class="na"&gt;[[ $str1 !&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;$str2 ]] 不等&lt;/span&gt;

&lt;span class="k"&gt;[[ $str1 &amp;gt; $str2 ]]&lt;/span&gt;
&lt;span class="k"&gt;[[ $str1 &amp;lt; $str2 ]]&lt;/span&gt;

&lt;span class="err"&gt;[[&lt;/span&gt; &lt;span class="err"&gt;-z&lt;/span&gt; &lt;span class="err"&gt;$str1&lt;/span&gt; &lt;span class="err"&gt;]]&lt;/span&gt;  &lt;span class="err"&gt;空&lt;/span&gt;
&lt;span class="err"&gt;[[&lt;/span&gt; &lt;span class="err"&gt;-n&lt;/span&gt; &lt;span class="err"&gt;$str1&lt;/span&gt; &lt;span class="err"&gt;]]&lt;/span&gt;  &lt;span class="err"&gt;非空&lt;/span&gt;

&lt;span class="err"&gt;if&lt;/span&gt; &lt;span class="k"&gt;[[ -n $str1 ]] &amp;amp;&amp;amp; [[ -z $str2 ]]&lt;/span&gt;
&lt;span class="err"&gt;then&lt;/span&gt;
    &lt;span class="err"&gt;commands&lt;/span&gt;&lt;span class="c1"&gt;;&lt;/span&gt;
&lt;span class="err"&gt;fi&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;find&lt;/h3&gt;
&lt;p&gt;搜索指定目录下的文件，从开始于父目录，然后搜索子目录&lt;/p&gt;
&lt;p&gt;基本&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;find base_path

# 打印文件和目录列表
find . -print  #默认\n分割文件名
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;文件名&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;find path -name &amp;quot;*.txt&amp;quot; -print
          -iname  忽略大小写

多个条件 or
find . \( -name &amp;quot;*.txt&amp;quot; -o -name &amp;quot;*.py&amp;quot; \)
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;文件路径&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;通配符
find /home/users -path &amp;quot;*slynux*&amp;quot; -print

正则
find . -regex &amp;quot;.*\(\.py\|\.sh\)$&amp;quot;
       -iregex 忽略大小写
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;否定参数&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;find . ! -name &amp;quot;*.txt&amp;quot; -print
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;根据文件类型&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;find . -type d -print
f 普通文件
l 符号链接
d 目录
c 字符设备
b 块设备
s 套接字
p Fifo
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;设定目录深度&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;find . -maxdepth 1 -type f -print
find . -mindepth 2 -type f -print
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;根据文件时间搜索&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;计量单位 天
-atime 最近一次访问时间
-mtime 最后一次被修改时间
-ctime 文件元数据，最近一次修改时间

find . -type f -atime -7 -print #最近七天内被访问的
find . -type f -atime 7 -print  #恰好在七天前
                      +7 -print #超过七天

计量单位 分钟
-amin 访问时间
-mmin 修改时间
-cmin 变化时间

find . -type f -amin +7 -print #访问时间超过7分钟的

find . -type f -newer file.txt -print  #用于比较时间戳的参考文件，比参考文件更新的文件
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;基于文件大小的搜索&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;find . -type f -size +2k
+ 大于  -小于   无符号，恰好等于

b 块
c 字节
w 字（2字节）
k 千字节
M 兆字节
G 吉字节
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;删除匹配的文件&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;find . -type f -name &amp;quot;*.swp&amp;quot; -delete
#注意：-delete位置一定是最后
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;文件权限及所有权&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;find . -type f -perm 644 -print

find . -type f -user slynux -print
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;执行命令或动作(最强大的命令)&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;find . -type f -user root -exec chown slynux {} \;
find . -type f -exec cp {} OLD \;
find . -iname &amp;quot;abc.txt&amp;quot; -exec md5sum {} \;

{} 江北替换成对应文件名
exec无法结合多个命令，可以将多个命令放入脚本，调用之
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;跳过指定目录&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;find . \( -name &amp;quot;.git&amp;quot; -prune \) -name &amp;#39;*.txt&amp;#39;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;xargs&lt;/h3&gt;
&lt;p&gt;将标准输入数据转化成命令行参数&lt;/p&gt;
&lt;p&gt;将stdin接收到的数据重新格式化，再将其作为参数传给其他命令&lt;/p&gt;
&lt;p&gt;多行输入转化成单行输出&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;cat  example.txt | xargs  #空格替换掉\n
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;切成多行，每行n个参数&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;cat examplet.txt | xargs -n 3
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;可以指定分隔符&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;echo &amp;quot;aaaXbbbXccc&amp;quot; | xargs -d &amp;#39;X&amp;#39;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;将参数传递给脚本(类似循环)&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;cat args.txt | xargs -n 1 ./cecho.sh

./cecho.sh -p arg1 1
需要变更
cat args.txt | xargs -I {} ./cecho.sh -p {} 1
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;find与xargs组合&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;find . -type f -name &amp;quot;*.txt&amp;quot; -print | xargs rm -rf
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;其他&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="x"&gt;cat file | ( while read arg; do cat &lt;/span&gt;&lt;span class="p"&gt;$&lt;/span&gt;&lt;span class="nv"&gt;arg&lt;/span&gt;&lt;span class="x"&gt;; done )&lt;/span&gt;
&lt;span class="x"&gt;cat file | xargs -I &lt;/span&gt;&lt;span class="err"&gt;{&lt;/span&gt;&lt;span class="x"&gt;} cat &lt;/span&gt;&lt;span class="err"&gt;{&lt;/span&gt;&lt;span class="x"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;tr&lt;/h3&gt;
&lt;p&gt;tr可以对来自标准输入的字符进行替换，删除以及压缩(translate, 可以将一组字符变成另一组字符)&lt;/p&gt;
&lt;p&gt;tr只能通过stdin，无法通过其他命令行进行接收参数&lt;/p&gt;
&lt;p&gt;格式&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;tr [options] source-char-set replace-char-set
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;选项&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;-c 取source-char-set补集，通常与-d/-s配合
-d 删除字source-char-set中的所列的字符
-s 浓缩重复字符，连续多个变成一个
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;字符替换&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;cat /proc/12501/environ | tr &amp;#39;\0&amp;#39; &amp;#39;\n&amp;#39;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;大小写替换&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;echo  &amp;quot;HELLO&amp;quot; | tr &amp;#39;A-Z&amp;#39; &amp;#39;a-z&amp;#39;
cat text | tr &amp;#39;\t&amp;#39; &amp;#39; &amp;#39;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;删除字符&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;echo &amp;quot;hello 123 world 456&amp;quot;| tr -d &amp;#39;0-9&amp;#39;
hello  world
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;字符集补集&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;echo &amp;quot;hello 1 char 2&amp;quot; | tr -d -c &amp;#39;0-9&amp;#39;  #删除非0-9
12
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;压缩字符&lt;/p&gt;
&lt;p&gt;连续的重复字符&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;echo &amp;quot;GNU is    not UNix&amp;quot; | tr -s &amp;#39; &amp;#39;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;字符类&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;alnum 字母和数字
alpha 字母
cntrl 控制字符
digit 数字
graph 图形字符
lower 小写字母
print 可打印字符
punct 标点符号
space 空白字符
upper 大写字母
xdigit 十六进制字符

tr &amp;#39;[:lower:]&amp;#39; &amp;#39;[:upper:]&amp;#39;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;md5sum&lt;/h3&gt;
&lt;p&gt;32个字符的十六进制串&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;md5sum filename
md5sum filename1 filename2
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;sha1sum&lt;/h3&gt;
&lt;p&gt;40个字符十六进制串&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;sha1sum file
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;对目录进行校验&lt;/h3&gt;
&lt;p&gt;需安装md5deep软件包&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;md5deep/sha1deep
md5deep -rl dirname
         r递归，l相对路径
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;sort&lt;/h3&gt;
&lt;p&gt;语法&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;sort [options] [file(s)]

-c 检查是否已排序
-u 丢弃所有具有相同键值的记录

-b 忽略开头空白
-d 字典序
-g 一般数值，以浮点数类型比较字段，仅支持gnu
-i 忽略无法打印的字符

-k 定义排序键值字段
-n 以整数类型比较字段
-r 倒转
-o 输出到指定文件
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;排序&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;sort file1 &amp;gt; file1.sorted
sort -o file1.sored file1
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;按数字, 要明确&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;sort -n file1
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;逆序&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;sort -r file
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;测试一个文件是否已经被排过序&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;sort -C file
if [ $? -eq 0 ]; then
    echo ssss
fi
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;合并两个排过序的文件，并不需要对合并后的文件进行再排序&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;sort -m sorted1 sorted2
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;根据键或者列排序(按照哪一个列)&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;sort -k 1 data
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;限定特定范围内一组字符&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;key=char4-char8
sort -k 2,3 data

sort -k2.4,5.6 file
第二个字段的第四个字符开始比较，直到第五个字段的第六个字符
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;忽略前导空白及字典序排序&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;sort -bd unsorted.txt
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;去重&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;sort a.txt | uniq
sort -u a.txt
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;uniq&lt;/h3&gt;
&lt;p&gt;用法&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;uniq file
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;只显示未重复的记录&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;uniq -u file
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;找出重复的行&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;uniq -d file
-s 可指定跳过前N个字符
-w 指定用于比较的最大字符数
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;统计各行出现的次数&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;uniq -c file
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;p57&lt;/p&gt;
&lt;h3&gt;tempfile&lt;/h3&gt;
&lt;p&gt;只有在基于Debian的发布版才有(Ubuntu/Debian)&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="x"&gt;temp_file=&lt;/span&gt;&lt;span class="p"&gt;$(&lt;/span&gt;&lt;span class="err"&gt;tempfile&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="x"&gt;&lt;/span&gt;
&lt;span class="x"&gt;等同&lt;/span&gt;
&lt;span class="x"&gt;temp_file=&amp;quot;/tmp/file-&lt;/span&gt;&lt;span class="p"&gt;$&lt;/span&gt;&lt;span class="nv"&gt;RANDOM&lt;/span&gt;&lt;span class="x"&gt;&amp;quot;&lt;/span&gt;

&lt;span class="err"&gt;#&lt;/span&gt;&lt;span class="p"&gt;$$&lt;/span&gt;&lt;span class="x"&gt;为进程id&lt;/span&gt;
&lt;span class="x"&gt;temp_file=&amp;quot;/tmp/var.&lt;/span&gt;&lt;span class="p"&gt;$$&lt;/span&gt;&lt;span class="x"&gt;&amp;quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;split&lt;/h3&gt;
&lt;p&gt;按大小分割文件, 单位k(KB), M, G, c(byte), w(word)&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;split -b 10k data.file
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;-d数字后缀，-a后缀长度&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;split -b 10k data.file -d -a 4
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;分割后指定文件名前缀&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;split -b 10k data.file file_prefix

设置后缀格式
split -b 10k data.file -d -a 4 file_prefix
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;根据行数分割&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;spilt -l 10 data
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;其扩展是csplit，可根据文件特性切分，关注&lt;/p&gt;
&lt;h3&gt;bash变量匹配切分&lt;/h3&gt;
&lt;p&gt;sample.jpg&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;file_jpg=&amp;quot;sample.jpg&amp;quot;

从右向左匹配
&lt;span class="cp"&gt;${&lt;/span&gt;&lt;span class="n"&gt;file_jpg&lt;/span&gt;&lt;span class="o"&gt;%.*&lt;/span&gt;&lt;span class="cp"&gt;}&lt;/span&gt;
#sample

从左向右匹配
&lt;span class="cp"&gt;${&lt;/span&gt;&lt;span class="n"&gt;file_jpg&lt;/span&gt;&lt;span class="c"&gt;#.*&lt;/span&gt;&lt;span class="cp"&gt;}&lt;/span&gt;
#jpg

% # 属于非贪婪
%% ## 属于贪婪
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;贪婪非贪婪&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;var=hack.fun.book.txt
&lt;span class="cp"&gt;${&lt;/span&gt;&lt;span class="n"&gt;var&lt;/span&gt;&lt;span class="o"&gt;%.*&lt;/span&gt;&lt;span class="cp"&gt;}&lt;/span&gt; #hack.fun.book
&lt;span class="cp"&gt;${&lt;/span&gt;&lt;span class="n"&gt;var&lt;/span&gt;&lt;span class="o"&gt;%%.*&lt;/span&gt;&lt;span class="cp"&gt;}&lt;/span&gt; #hack

&lt;span class="cp"&gt;${&lt;/span&gt;&lt;span class="n"&gt;var&lt;/span&gt;&lt;span class="c"&gt;#.*&lt;/span&gt;&lt;span class="cp"&gt;}&lt;/span&gt; #fun.book.txt
&lt;span class="cp"&gt;${&lt;/span&gt;&lt;span class="n"&gt;var&lt;/span&gt;&lt;span class="c"&gt;##.*&lt;/span&gt;&lt;span class="cp"&gt;}&lt;/span&gt; #txt
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;expect&lt;/h3&gt;
&lt;p&gt;实现自动化&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;spawn ./ineractive.sh
expect &amp;quot;Enter the number&amp;quot;
send &amp;quot;1\n&amp;quot;
expect &amp;quot;Enter name:&amp;quot;
send &amp;quot;hello\n&amp;quot;
expect eof

spawn指定需要自动化的命令
expect提供需要等待的消息
send发送消息
expect eof指明命令交互结束
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;dd&lt;/h3&gt;
&lt;p&gt;生成任意大小的文件&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;# 创建一个1M大小的文件junk.data
bs=2M count=2 则文件大小4M

dd if=/dev/zero of=junk.data bs=1M count=1
   输入文件     输出文件     块大小   复制块数

块大小单位
字节(1B) c
字(2B)   w
块(512B)   b
千字节(1024B) k
兆字节(1024KB) M
吉字节(1024MB) G
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;comm&lt;/h3&gt;
&lt;p&gt;两个文件之间比较，输出三列&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;onleA \t onlyB \t bothAB

comm A B -1 -2 #删除第一第二列
-3 删除第三列

可以得到A^B  A-B B-A
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;mkdir&lt;/h3&gt;
&lt;p&gt;“mkdir”(Make directory)命令在命名路径下创建新的目录。然而如果目录已经存在了，那么它就会返回一个错误信息”不能创建文件夹，文件夹已经存在了”(“cannot create folder, folder already exists”)&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;mkdir dirpath

mkdir -p dirpath1/dirpath2

#一次多个目录
mkdir -p /home/user/{test,test1,test2}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;注意：目录只能在用户拥有写权限的目录下才能创建&lt;/p&gt;
&lt;h3&gt;ls&lt;/h3&gt;
&lt;p&gt;ls命令是列出目录内容(List Directory Contents)的意思。运行它就是列出文件夹里的内容，可能是文件也可能是文件夹&lt;/p&gt;
&lt;p&gt;ls文件的内容关系&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;- 普通文件
d 目录
c 字符设备
b 块设备
l 符号链接
s 套接字
p 管道

文件权限序列
rwx
rwS  setuid(S)，特殊权限, 出现在x的位置, 允许用户以其拥有者的权限来执行文件, 即使这个可执行文件是由其他用户运行的

目录
r,允许读取目录中文件和子目录列表
w,允许在目录中创建或删除文件或目录
x,指明是否可以访问目录中的文件和子目录
rwt/rwT 粘滞位，只有创建该目录的用户才能删除目录中的文件，即使用户组和其他用户也有写权限，典型例子/tmp, 写保护
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;查看目录&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;ls -d */
ls -F | grep &amp;quot;/$&amp;quot;
ls -l | grep &amp;quot;^d&amp;quot;
find . -type d -maxdepth 1 -print
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;其他&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;ls -l    命令已详情模式(long listing fashion)列出文件夹的内容
ls -a    命令会列出文件夹里的所有内容，包括以”.”开头的隐藏文件
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;chmod&lt;/h3&gt;
&lt;p&gt;设置文件权限&lt;/p&gt;
&lt;p&gt;“chmod”命令就是改变文件的模式位。chmod会根据要求的模式来改变每个所给的文件，文件夹，脚本等等的文件模式（权限）。&lt;/p&gt;
&lt;p&gt;设置权限&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;user group others all
u    g     o      a

chmod u=rwx g=rw o=r filename

chmod u+x filename
chomd a+x filename #所有

chmod a-x filename

chmod 764 filename

#设置粘滞位
chmod a+t dirname

#递归改变

chmod 777 . -R
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;注意：对于系统管理员和用户来说，这个命令是最有用的命令之一了。在多用户环境或者服务器上，对于某个用户，如果设置了文件不可访问，那么这个命令就可以解决，如果设置了错误的权限，那么也就提供了为授权的访问。&lt;/p&gt;
&lt;h3&gt;chown&lt;/h3&gt;
&lt;p&gt;每个文件都属于一个用户组和一个用户“chown”命令用来改变文件的所有权，所以仅仅用来管理和提供文件的用户和用户组授权。&lt;/p&gt;
&lt;p&gt;改变所有权&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;chown user.group filename
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;递归&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;chown -R user.group .
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;每次都以其他用户身份执行(允许其他用户以文件所有者的身份来执行)&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;chomod +s executable_file

chown root.root executable_file
chmod +s executable_file
./executable_file
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;chattr&lt;/h3&gt;
&lt;p&gt;创建不可修改文件&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;chattr +i file
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;一旦被设置为不可修改, 任何用户包括超级用户都不能删除该文件, 除非其不可修改的属性被移除&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;chattr -i file
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;touch&lt;/h3&gt;
&lt;p&gt;“touch”命令代表了将文件的访问和修改时间更新为当前时间。&lt;/p&gt;
&lt;p&gt;touch命令只会在文件不存在的时候才会创建它(空白文件)。如果文件已经存在了，它会更新时间戳，但是并不会改变文件的内容。&lt;/p&gt;
&lt;p&gt;空白文件&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="x"&gt;touch filename&lt;/span&gt;

&lt;span class="x"&gt;for name &lt;/span&gt;&lt;span class="err"&gt;{&lt;/span&gt;&lt;span class="x"&gt;1..100}.txt&lt;/span&gt;
&lt;span class="x"&gt;do&lt;/span&gt;
&lt;span class="x"&gt;    touch &lt;/span&gt;&lt;span class="p"&gt;$&lt;/span&gt;&lt;span class="nv"&gt;name&lt;/span&gt;&lt;span class="x"&gt;&lt;/span&gt;
&lt;span class="x"&gt;done&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;修改文件访问时间&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;touch -a &amp;quot;Fri Jun 25 20:50:14 IST 1999&amp;quot; filename
touch -m #修改文件内容的修改时间
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;修改文件或目录的时间戳(YYMMDDhhmm)&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;touch -t 0712250000 file
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;注意：touch 可以用来在用户拥有写权限的目录下创建不存在的文件。&lt;/p&gt;
&lt;h3&gt;ln&lt;/h3&gt;
&lt;p&gt;建立软连接&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;ln -s target symbolic_link_name
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;如果目的路径已经存在，而没有指定 -f 标志，ln 命令不会创建新的链接，而是向标准错误写一条诊断消息并继续链接剩下的 SourceFiles。&lt;/p&gt;
&lt;p&gt;-f 促使 ln 命令替换掉任何已经存在的目的路径&lt;/p&gt;
&lt;h3&gt;readlink&lt;/h3&gt;
&lt;p&gt;读取链接对应真是路径&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;readlink web

 readlink ~/.vim
 /Users/ken/github/k-vim
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;file&lt;/h3&gt;
&lt;p&gt;通过查看文件内容来找出特定类型的文件&lt;/p&gt;
&lt;p&gt;打印文件类型信息&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;file filename
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;打印不包含文件名在内&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;file -b filename
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;e.g.&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;file /etc/passwd
/etc/passwd: ASCII English text

file -b /etc/passwd
ASCII English text
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;读文件&lt;/h3&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;while read line;
do
    something
done &amp;lt; filename
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;diff&lt;/h3&gt;
&lt;p&gt;生成文件差异&lt;/p&gt;
&lt;p&gt;非一体化&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="gh"&gt;diff version1.txt version2.txt&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;一体化, 可读性更好&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="gh"&gt;diff -u version.txt&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;使用patch将命令应用于任意一个文件&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="gh"&gt;diff -u version1.txt version2.txt &amp;gt; version.patch&lt;/span&gt;
patch -p1 version1.txt &amp;lt; version.patch
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;递归作用于目录&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="gh"&gt;diff -Naur directory1 directory2&lt;/span&gt;

&lt;span class="gd"&gt;-N 所有缺失的文件作为空文件&lt;/span&gt;
&lt;span class="gd"&gt;-a 所有文件视为文本文件&lt;/span&gt;
&lt;span class="gd"&gt;-u 一体化输出&lt;/span&gt;
&lt;span class="gd"&gt;-r 递归遍历&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;head&lt;/h3&gt;
&lt;p&gt;前10行打印&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;head file
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;前n行&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;head -n 4 file
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;扣除最后N行之外的所有行&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;head -n -5 file
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;tail&lt;/h3&gt;
&lt;p&gt;最后10行&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;tail file
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;打印最后五行&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;tail -n 5 file
tail -5 file
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;扣除前n行&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;tail -n +(N+1)
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;实时动态打印&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;tail -f growing_file
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;当某个给定进程结束后,  tail随之终结&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="x"&gt;tail -f file --PID &lt;/span&gt;&lt;span class="p"&gt;$&lt;/span&gt;&lt;span class="nv"&gt;PID&lt;/span&gt;&lt;span class="x"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;pushd/popd&lt;/h3&gt;
&lt;p&gt;将当前路径压入栈&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;pushd
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;压入某个路径&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;pushd /home/ken
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;查看当前路径列表&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;dirs
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;切换到某一个&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;#dirs从左到右编号 0 -
pushd +3
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;移除最近压入栈的路径并切换到下一个目录&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;popd
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;cd&lt;/h3&gt;
&lt;p&gt;经常使用的“cd”命令代表了改变目录。它在终端中改变工作目录来执行，复制，移动，读，写等等操作&lt;/p&gt;
&lt;p&gt;切换到上一目录&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;cd -
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;会到HOME目录&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;cd
cd ~
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;会到上一级目录&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;cd ..
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;wc&lt;/h3&gt;
&lt;p&gt;Word Count&lt;/p&gt;
&lt;p&gt;统计行数&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;wc -l file
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;统计单词数&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;wc -w file
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;统计字符数&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;wc -c file
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;统计所有&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;wc file
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;统计最长行的长度&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;wc file -L
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;tree&lt;/h3&gt;
&lt;p&gt;以图形化的树状结构打印文件和目录的结构，需要自行安装&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;tree ~/unixfile
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;重点标记出匹配某种样式的文件&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;tree PATH -P &amp;quot;*.sh&amp;quot;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;只标记符合样式之外的文件&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;tree path -I PATTERN
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;同时打印文件和目录大小&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;tree -h
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;grep&lt;/h3&gt;
&lt;p&gt;文本搜索工具, 支持正则表达式和通配符&lt;/p&gt;
&lt;p&gt;‘grep‘命令搜索指定文件中包含给定字符串或者单词的行&lt;/p&gt;
&lt;p&gt;基本用法&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;grep &amp;quot;match_pattern&amp;quot; file1 file2
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;使用颜色重点标记&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;grep word filename --color=auto
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;扩展型使用正则&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;grep -E &amp;quot;[a-z]+&amp;quot;
egrep &amp;quot;[a-z]+&amp;quot;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;只输出匹配到的文本部分&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;grep -o word filename
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;除匹配行外的所有行&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;grep -v word filename
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;统计匹配行数&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;grep -c &amp;#39;text&amp;#39; filename
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;打印出包含匹配字符串的行数&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;grep linux -n filename
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;打印样式匹配所位于的字符或字节的偏移&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;echo &amp;quot;gnu is not unix&amp;quot; | grep -b -o &amp;quot;not&amp;quot;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;搜索多个文件，找出匹配文本位于哪个文件中&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;grep -l linux file1 file2
取反
grep -L
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;递归搜索目录&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;grep -R &amp;quot;text&amp;quot; dir
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;忽略大小写&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;grep -i &amp;quot;hello&amp;quot; filename
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;匹配多个样式&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;grep -e &amp;quot;pattern1&amp;quot; -e &amp;quot;pattern2&amp;quot; file
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;运行匹配脚本&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;grep -f pattern_file source_file

pattern_file:
hello
cool
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;在搜索中包含、排除文件&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;grep --include *.{c,cpp} word file
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;排除&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;grep --exclude &amp;quot;Readme&amp;quot; filename
--exclude-dir
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;静默输出，用于判断(不会产生任何输出)&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;grep -q word file
if [ $? -eq 0 ]
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;打印匹配行之前，之后的行&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;grep -A 3 之后3行
grep -B 3 之前
grep -C 3 前后
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;使用行缓冲&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;在使用tail -f命令时是可以及时看到文件的变化的，但是如果再加上一个grep命令，可能看到的就不那么及时了，
因为grep命令在buffer写不满时就不输出，可以通过选项  --line-buffered 来搞定，如：

tail -f file.txt | grep something  --line-buffered
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;cut&lt;/h3&gt;
&lt;p&gt;语法&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;cut -c list [ file ... ]
cut -f list [ -d delim ] [ file ...]

-c list 以字符为主，作剪切操作
-f list 以字段为主，作剪切操作
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;提取字段或列&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;#第一列
cut -f1 filenam

#第二三列
cut -f2,3 filename
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;提取补集&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;cut -f1 --complement filename
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;指定字段分隔符&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;cut -d &amp;quot;;&amp;quot; -f2 filename
cut -d : -f 1,5 /etc/passwd
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;指定字符&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;-b 字节
-c 字符
-f 字段

cut -c1-5 filename
N-
N-M
-M

ls -l | cut -c 1-10
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;指定输出分隔符&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;cut -c1-3,6-9 --output-delimiter &amp;quot;,&amp;quot;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;join&lt;/h3&gt;
&lt;p&gt;语法&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;join [options] file1 file2

选项
-1 field1
-2 field2
-o file.field
-t separator
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;例子&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;join file1 file2
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;sed&lt;/h3&gt;
&lt;p&gt;sed(Stream editor)流编辑器, 可以配合正则使用, 进行替换等&lt;/p&gt;
&lt;p&gt;sed替换语法&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;sed &amp;#39;s/pattern/replace_string/&amp;#39; file
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;将结果直接运用于源文件&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;-i 用于, 直接修改源文件

替换第一个
sed -i &amp;#39;s/pattern/replace_string/&amp;#39; file

替换第二个
sed -i &amp;#39;s/pattern/replace_string/2&amp;#39; file

替换所有
sed -i &amp;#39;s/pattern/replace_string/g&amp;#39; file

从第N处开始替换
sed -i &amp;#39;s/pattern/replcae_string/2g&amp;#39; file
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;移除空白行&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;sed &amp;#39;/^$/d&amp;#39; file
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;已匹配字符串标记&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;引用匹配到的
sed &amp;#39;s/\w\+/[&amp;amp;]/g&amp;#39; filename
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;组合多个表达式&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;sed &amp;#39;exp1&amp;#39; | sed &amp;#39;exp2&amp;#39;
等价
sed &amp;#39;exp1;exp2&amp;#39;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;使用引用&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="x"&gt;sed &amp;quot;s/&lt;/span&gt;&lt;span class="p"&gt;$&lt;/span&gt;&lt;span class="nv"&gt;text&lt;/span&gt;&lt;span class="x"&gt;/HELLO/&amp;quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;子串匹配标记(后向引用，最多9个)&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;sed &amp;#39;s/\([a-z]\+\)&amp;#39; \([A-Z\]\+\)/\2 \1/&amp;#39; filename
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;保存到文件&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;sed &amp;#39;s/pattern/replacement/&amp;#39; -i outfile
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;使用其他分隔符&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;sed &amp;#39;s#/home/#/tmp/#&amp;#39;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;awk&lt;/h3&gt;
&lt;p&gt;基本结构&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;awk -F &amp;#39;-&amp;#39; &amp;#39;BEGIN{statements} {statements} END{statements}&amp;#39; file
表达式中单引号可以换成双引号
BEGIN -&amp;gt; 每一行，执行statements, 执行END
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;打印某一列&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;awk -F &amp;#39;-&amp;#39; &amp;#39;{print $0}&amp;#39; file #全部
awk -F &amp;#39;-&amp;#39; &amp;#39;{print $2}&amp;#39; file #第二列
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;print拼接字符&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;awk &amp;#39;{var=&amp;quot;v1&amp;quot;; var1=&amp;quot;v2&amp;quot;; print var1&amp;quot;-&amp;quot;var2;}&amp;#39;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;特殊变量&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="x"&gt;NR nuber of records, 记录数&lt;/span&gt;
&lt;span class="x"&gt;NF number of fields, 字段数&lt;/span&gt;
&lt;span class="p"&gt;$&lt;/span&gt;&lt;span class="x"&gt;0 当前行文本&lt;/span&gt;
&lt;span class="p"&gt;$&lt;/span&gt;&lt;span class="x"&gt;1 第一字段&lt;/span&gt;
&lt;span class="p"&gt;$&lt;/span&gt;&lt;span class="x"&gt;2 第二字段&lt;/span&gt;
&lt;span class="p"&gt;$&lt;/span&gt;&lt;span class="nv"&gt;NF&lt;/span&gt;&lt;span class="x"&gt; 最后一个字段&lt;/span&gt;

&lt;span class="x"&gt;FILENAME 当前输入文件的名称&lt;/span&gt;
&lt;span class="x"&gt;FNR 当前输入文件记录数&lt;/span&gt;
&lt;span class="x"&gt;FS 字段分隔字符&lt;/span&gt;
&lt;span class="x"&gt;OFS 输出字段分隔符，默认&amp;quot; &amp;quot;&lt;/span&gt;
&lt;span class="x"&gt;ORS 输出记录分隔符，默认&amp;quot;\n&amp;quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;统计行数&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;awk &amp;#39;END{print NF}&amp;#39;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;将外部变量值传递给awk&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="x"&gt;awk -v VARIABLE=&lt;/span&gt;&lt;span class="p"&gt;$&lt;/span&gt;&lt;span class="nv"&gt;VAR&lt;/span&gt;&lt;span class="x"&gt; &amp;#39;&lt;/span&gt;&lt;span class="err"&gt;{&lt;/span&gt;&lt;span class="x"&gt; print VARIABLE }&amp;#39;&lt;/span&gt;
&lt;span class="x"&gt;awk &amp;#39;&lt;/span&gt;&lt;span class="err"&gt;{&lt;/span&gt;&lt;span class="x"&gt;print v1, v2}&amp;#39; v1=&lt;/span&gt;&lt;span class="p"&gt;$&lt;/span&gt;&lt;span class="nv"&gt;var1&lt;/span&gt;&lt;span class="x"&gt; v2=&lt;/span&gt;&lt;span class="p"&gt;$&lt;/span&gt;&lt;span class="nv"&gt;var2&lt;/span&gt;&lt;span class="x"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;读取行&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;seq 5 | awk &amp;#39;{ getline var; print var}&amp;#39;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;进行行过滤&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;awk &amp;#39;NR&amp;lt;5&amp;#39; #行号小于5
awk &amp;#39;NR==1,NR==4&amp;#39; #行号在1到5之间
awk &amp;#39;/linux/&amp;#39; #包含样式linux
awk &amp;#39;!/linux/&amp;#39; #不包含
awk &amp;#39;$1 ~/jones/&amp;#39; #第一个字段包含jones

tail file
awk &amp;#39;NR &amp;lt;= 10&amp;#39; file
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;设定分隔符&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="x"&gt;awk -F: &amp;#39;&lt;/span&gt;&lt;span class="err"&gt;{&lt;/span&gt;&lt;span class="x"&gt; print &lt;/span&gt;&lt;span class="p"&gt;$&lt;/span&gt;&lt;span class="nv"&gt;NF&lt;/span&gt;&lt;span class="x"&gt; }&amp;#39; file&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;设定输出分隔符&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;awk -F: -v &amp;quot;OFS=-&amp;quot; &amp;#39;{print $1,$2}&amp;#39; /etc/passwd
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;打印空行&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;awk &amp;#39;NF&amp;gt;0 {print $0}&amp;#39;
or
awk &amp;#39;NF&amp;gt;0&amp;#39; #未指定action默认打印
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;print和printf&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;awk -F: &amp;#39;{print &amp;quot;User&amp;quot;, $1, &amp;quot;is really&amp;quot;, $5}&amp;#39; /etc/passwd
awk -F: &amp;#39;{printf &amp;quot;User %s is really %s\n&amp;quot;, $1, $5}&amp;#39; /etc/passwd
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;awk中使用循环&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="x"&gt;for(i=0;i&amp;lt;10;i++) &lt;/span&gt;&lt;span class="err"&gt;{&lt;/span&gt;&lt;span class="x"&gt; print &lt;/span&gt;&lt;span class="p"&gt;$&lt;/span&gt;&lt;span class="nv"&gt;i&lt;/span&gt;&lt;span class="x"&gt;; }&lt;/span&gt;

&lt;span class="x"&gt;for(i in array) &lt;/span&gt;&lt;span class="err"&gt;{&lt;/span&gt;&lt;span class="x"&gt; print array[i] }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;内建函数&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;length(str)
index(str,search_str)
split(str,array,delimiter) 用界定符生成一个字符串列表
substr(string, start, end) #子串
sub(regex, replacement_str, str) #正则替换首个匹配位置
gsub(regex, replacement_str, string) #最后一个匹配位置
match(string, regex) #检查是否能够匹配字符串
tolower(string) #转小写
toupper(string) #转大写
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;写成脚本文件&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;BEGIN {}
pattern1 {action1}
pattern2 {action2}
END {}
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;文件迭代&lt;/h3&gt;
&lt;p&gt;读文件行&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="x"&gt;while read line;&lt;/span&gt;
&lt;span class="x"&gt;do&lt;/span&gt;
&lt;span class="x"&gt;    echo &lt;/span&gt;&lt;span class="p"&gt;$&lt;/span&gt;&lt;span class="nv"&gt;line&lt;/span&gt;&lt;span class="x"&gt;;&lt;/span&gt;
&lt;span class="x"&gt;done &amp;lt; file.txt&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;迭代每个单词&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="x"&gt;for word in &lt;/span&gt;&lt;span class="p"&gt;$&lt;/span&gt;&lt;span class="nv"&gt;line&lt;/span&gt;&lt;span class="x"&gt;;&lt;/span&gt;
&lt;span class="x"&gt;do&lt;/span&gt;
&lt;span class="x"&gt;    echo &lt;/span&gt;&lt;span class="p"&gt;$&lt;/span&gt;&lt;span class="nv"&gt;word&lt;/span&gt;&lt;span class="x"&gt;;&lt;/span&gt;
&lt;span class="x"&gt;done&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;迭代每一个字符&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;for((i=0;i&lt;span class="err"&gt;&amp;lt;&lt;/span&gt;&lt;span class="cp"&gt;${&lt;/span&gt;&lt;span class="c"&gt;#word&lt;/span&gt;&lt;span class="cp"&gt;}&lt;/span&gt;;i++))
do
    echo &lt;span class="cp"&gt;${&lt;/span&gt;&lt;span class="n"&gt;word&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="cp"&gt;}&lt;/span&gt; ;
done
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;paste&lt;/h3&gt;
&lt;p&gt;按列合并文件&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;paste file1 file2 file3
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;指定分隔符&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;paste file1 file2 -d &amp;#39;,&amp;#39;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;tac&lt;/h3&gt;
&lt;p&gt;逆序打印&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;tac file1 file2
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;rev&lt;/h3&gt;
&lt;p&gt;接收一个文件或stdin作为输入, 逆序打印每一行内容&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;echo &amp;quot;abc&amp;quot; | rev
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;wget&lt;/h3&gt;
&lt;p&gt;Wget是用于非交互式（例如后台）下载文件的免费工具.支持HTTP, HTTPS, FTP协议和 HTTP 代理(选项多, 用法灵活)&lt;/p&gt;
&lt;p&gt;一个用于文件下载的命令行工具&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;wget URL1 URL2
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;指定保存文件名&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;wget URL -O local.txt
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;指定日志，默认达到stdout&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;wget URL -O local.txt -o log.txt
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;指定重复尝试次数&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;wget -t 5 URL
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;下载限速&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;wget --limit-rate 20k url
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;指定限额&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;wget -Q 100m url
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;断点续传&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;wget -c URL

$ wget -c -t 100 -T 120 http://www.linux.com/xxxx.data

当文件特别大或者网络特别慢的时候，往往一个文件还没有下载完，连接就已经被切断，此时就需要断点续传。
wget的断点续传是自动的。
-c 选项的作用为断点续传。
-t 参数表示重试次数(例如重试100次，-t 100，如果设成-t 0，表示无穷次重试，直到连接成功)
-T 参数表示超时等待时间，例如-T 120，表示等待120秒连接不上就算超时
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;复制或镜像整个网站&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;wget --mirror exampledomain.com
wget -r -N -l DEPTH URL
     递归，允许对文件使用时间戳，层级
$ wget -r -np -nd http://www.linux.com/packs/

-np 的作用是不遍历父目录
-nd 表示不在本机重新创建目录结构
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;访问需要认证的HTTP/FTP&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;wget --user username --password pass URL
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;post请求&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;wget url -post-data &amp;quot;name=value&amp;quot; -O output.html
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;批量下载&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;wget -i downloads.txt #将文件地址写入一个文件
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;用wget命令执行ftp下载&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;wget -m ftp://username:password@hostname
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;curl&lt;/h3&gt;
&lt;p&gt;基本用法&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;curl url &amp;gt; index.html
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;不显示进度信息&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;curl URL --slient
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;将内容写入文件，而非标准输出&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;curl URL --slient -O
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;写入指定文件&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;curl URL --slient -o filename
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;显示进度条&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;curl url -o index.html --progress
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;断点续传&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;curl -C - URL
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;设置参照页字符串&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;curl --referer Referer_URL target_URL
跳转到target_URL,其头部referer为Referer_URL
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;设置cookie&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;curl url --cookie &amp;quot;user=slynux;pass=hack&amp;quot;
另存为一个文件

curl URL --cookie-jar cookie_file
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;设置用户代理&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;curl URL --user-agent &amp;quot;Mozilla/5.0&amp;quot;
头部信息
curl -H &amp;quot;Host: www.slynux.org&amp;quot; -H &amp;quot;Accept-language: en&amp;quot; url
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;限定下载带宽&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;curl url --limit-rate 20k
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;指定最大下载量(可下载的最大文件大小)&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;curl url --max-filesize bytes
超出限制的话，返回非0
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;进行认证&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;curl -u user:pass url
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;只打印头部信息,不下载远程文件&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;curl -I url
curl -head url
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;发送post请求&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;curl URL -d &amp;quot;va1=1&amp;amp;va2=2&amp;quot;
         --data
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;lynx&lt;/h3&gt;
&lt;p&gt;将网页以ascii字符形式下载&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;lynx -dump URL &amp;gt; webpage_as_text.txt
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;打印出网站的文本板块而非html&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;lynx -dump url
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;生成信息文件&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;lynx -traversal url
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;tar&lt;/h3&gt;
&lt;p&gt;“tar”命令是磁带归档(Tape Archive)，对创建一些文件的的归档和它们的解压很有用。&lt;/p&gt;
&lt;p&gt;将多个文件和文件夹保存成单个文件, 同时还能保留所有的文件属性&lt;/p&gt;
&lt;p&gt;对文件进行归档&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;-c create file,创建文件
-f specify filename,指定文件名

tar -cf output.tar file1 file2 file3
tar -cf output.tar *.txt

tar -cvf output.tar *.txt
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;向归档中追加文件&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;tar -rvf original.tar new_file
-r,追加
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;查看过程中更多信息&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;tar -tvvf archive.tar
-v/-vv, verbose
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;提取文件或文件夹&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;-x, exact
tar -xf archive.tar

-C,指定文件
tar -xf archive.tar -C /path/to/extraction_directory


tar -xvf archive.tar
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;提取指定文件&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;tar -xvf file.tar file1 file4
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;拼接两个归档文件&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;tar -Af file1.tar file2.tar
#file2合并到file1中
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;只有在文件内容修改时间更新(newer),才进行添加&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;tar -uvvf archive.tar filea
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;比较归档文件与文件系统中的内容&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;tar -df archive.tar filename1 filename2
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;从归档文件中删除文件&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;tar -f archive.tar --delete file1 file2
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;提取到某个目录&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt; tar zxvf package.tar.gz -C new_dir
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;压缩归档文件&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;gzip/gunzip -&amp;gt; .gz
f.tar.gz   -z
tar -czvf 
tar -xzvf

bzip/bunzip -&amp;gt; .bz2
f.tar.bz2  -j

f.tar.lzma --lzma
f.tar.lzo
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;从归档中排除部分文件&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;tar -cf arch.tar * --exclude &amp;quot;*.txt&amp;quot;
cat list
   filea
   fileb
tar -cf arch.tar * -X list
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;排除版本控制文件&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;tar --exclude-vcs -czvvf source.tar.gz files
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;打印总字节数&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;tar -cf arc.tar * --exclude &amp;quot;*.txt&amp;quot; --totals
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;cpio&lt;/h3&gt;
&lt;p&gt;使用频率不高&lt;/p&gt;
&lt;p&gt;归档，保留文件属性（权限、所有权等）&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;echo file1 file2 | cpio -ov &amp;gt; archive.cpio
-o 指定输出
-v 打印归档文件列表
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;列出cpio中的文件内容&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;cpio -it &amp;lt; archive.cpio
-i指定输入
-t列出归档文件中的内容
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;gzip&lt;/h3&gt;
&lt;p&gt;压缩，会删除源文件&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;gzip filename
#got filename.gz
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;解压&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;gunzip filename.gz
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;列出文件属性信息&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;gzip -l text.gz
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;stdin读入文件并写出到stdout&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;cat file | gzip -c &amp;gt; file.gz
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;压缩归档文件&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;tar -czvvf archive.tar.gz [files]
or
tar -cvvf archive.tar.gz [files]
gzip archive.tar
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;指定压缩率&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;1-9,1最低，但速度最快
gzip -9 test.img
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;zcat&lt;/h3&gt;
&lt;p&gt;无需解压缩，直接从.gz中提取内容&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;zcat test.gz
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;bzip&lt;/h3&gt;
&lt;p&gt;更大的压缩率&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;bzip2 filename
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;解压缩&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;bunzip2 filename.bz2
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;stdin到stdout&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;cat file &amp;gt; bzip2 -c &amp;gt; file.tar.bz2
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;压缩归档&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;tar -cjvvf archive.tar.bz2 [files]
or
tar -cvvf archive.tar [files]
bzip2 archive.tar
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;保留输入文件&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;bunzip2 test.bz2 -k
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;压缩率&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;bzip2 -9 test.img
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;lzma&lt;/h3&gt;
&lt;p&gt;比gzip/bzip2更好的压缩率&lt;/p&gt;
&lt;p&gt;压缩&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;lzma filename
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;解压&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;unlzma filename.lzma
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;stdin到stdout&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;cat file | lzma -c &amp;gt; file.lzma
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;创建归档&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;tar -cavvf archive.tar.lzma [files]
    -xavf
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;保留输入文件&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;lzma test.bz2 -k
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;压缩率&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;lzma -9 test.img
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;zip&lt;/h3&gt;
&lt;p&gt;压缩&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;zip archive_name.zip [source files/dirs]
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;对目录和文件进行递归操作&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;zip -r archive.zip folder1 file2
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;base64&lt;/h3&gt;
&lt;p&gt;编码&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;base64 filename &amp;gt; outfile
cat file | base64 &amp;gt; outfile
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;解码&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;base64 -d file &amp;gt; outfile
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;md5sum&lt;/h3&gt;
&lt;p&gt;“md5sum”就是计算和检验MD5信息签名。
md5 checksum(通常叫做哈希)使用匹配或者验证文件的文件的完整性，因为文件可能因为传输错误，磁盘错误或者无恶意的干扰等原因而发生改变。&lt;/p&gt;
&lt;p&gt;单向散列&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;md5sum file
sha1sum file
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;rsync&lt;/h3&gt;
&lt;p&gt;可以对位于不同位置的文件和目录进行备份, 借助差异计算和压缩技术实现最小化数据传输量&lt;/p&gt;
&lt;p&gt;要确保远端安装了 openssh&lt;/p&gt;
&lt;p&gt;从一个目录复制到另一个目录&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;rsync -av source_path dest_path
-a 进行归档  -v打印细节
路径可以使本地，也可以是远端路径

e.g.
rsync -av /home/test /home/backups/ #复制到backups目录下
rsync -av /home/test /home/backups  #创建backups目录, 复制
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;备份到远程服务器&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;rsync -av source_path user@host:PATH
可以反向
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;改善传输速度&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;rsync -avz source destination
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;排除文件&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;rsync -avz source dest --exclude &amp;quot;*.txt&amp;quot;
                       --exclude-from FILEPATH
FILEPATH:
*.bak
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;更新备份时，删除不存在的文件&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;rsync -avz source dest --delete
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;git&lt;/h3&gt;
&lt;p&gt;初始化目录&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;git init
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;配置用户信息&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;git config --global user.name &amp;quot;wklken&amp;quot;
git config --global user.email &amp;quot;wklken@yeah.net&amp;quot;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;加到远端&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;git remote add origin user@remotehost:/home/backup/backup.git
git push origin master
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;添加&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;git add *
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;删除&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;git rm *.py
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;标记一个检查点&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;git commit -m &amp;quot;Commit message&amp;quot;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;查看日志&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;git log
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;回滚到某个版本&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;git checkout hashid [ filename ]
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;克隆&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;git clone url
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;dd&lt;/h3&gt;
&lt;p&gt;Dtat Definiton, 要注意参数顺序, 错误的参数会损毁所有数据&lt;/p&gt;
&lt;p&gt;可以用来转换和复制文件，大多数时间是用来复制iso文件(或任何其它文件)到一个usb设备(或任何其它地方)中去，所以可以用来制作USB启动器&lt;/p&gt;
&lt;p&gt;语法说明&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;dd if=SOURCE of=TARGET bs=BLOCK_SIZE count=COUNT
if/of  输入/输出文件或设备路径
bs块大小
count 限制复制到目标的字节数

dd if=/dev/zero of=/dev/sda1

#制作iso 从cdrom设备读取所有数据, 创建iso文件
dd if=/dev/cdrom of=cdrom.iso
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;备份恢复&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;dd if=/dev/sda1 of=x.img

dd if=x.img of=/dev/sda1
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;mount&lt;/h3&gt;
&lt;p&gt;mount 是一个很重要的命令，用来挂载不能自动挂载的文件系统。你需要root权限挂载设备。
在插入你的文件系统后，&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;mount --bind /source /destination

首先运行”lsblk”命令，识别出你的设备，然后把分配的设备名记下来。
root@tecmint:~# lsblk
创建一个任何名字的目录，但是最好和引用相关。

root@tecmint:~# su
Password:
root@tecmint:~# cd /dev
root@tecmint:~# mkdir usb
现在将“sdb1”文件系统挂载到“usb”目录.
root@tecmint:~# mount /dev/sdb1 /dev/usb
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;挂载镜像&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;mount -o loop file.img /mnt/mount_point
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;网络相关&lt;/h2&gt;
&lt;h3&gt;ifconfig&lt;/h3&gt;
&lt;p&gt;显示网络接口、子网掩码等详细信息&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;ifconfig
/sbin/ifconfig
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;打印某个特定网络接口&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;ifconfig iface_name

e.g.
ifconfig en1

HWaddr     MAC地址
inet addr  ip地址
Bcast      广播地址
Mask       子网掩码
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;设置网络接口ip&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;ifconfig wlan0 192.168.0.80
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;dns&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;cat /etc/resolv.conf

host google.com #Dns查找

nslookup google.com #更详细信息
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;修改dns/host&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;echo nameserver IP_ADDRESS &amp;gt;&amp;gt; /etc/resolv.conf

echo ip domain &amp;gt;&amp;gt; /etc/hosts
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;ping&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;ping www.baidu.com
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;路由信息&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;显示路由表
route

以数字形式显示地址
route -n
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;设置默认网关&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;route add default gw 192.168.0.1 wlan0
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;trace_route, 显示分组途径的所有网关的地址&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;traceroute google.com
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;ping&lt;/h3&gt;
&lt;p&gt;基本&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;ping ADDRESS  #主机名，域名或ip
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;PING命令可以得到RTT(Round Trip Time), 分组从源到目的主机的往返时间, 单位ms&lt;/p&gt;
&lt;p&gt;限制发送分组数&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;ping ADDRESS -c COUNT

ping
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;fping&lt;/h3&gt;
&lt;p&gt;同时ping一组ip, 而且响应非常快&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;fping -a ip1 ip2 -g
fping -a 192.160.1/24 -g
fping -a &amp;lt; ip.list

-a, 所有活动主机的ip
-g, 从IP/mask生成的ip地址范围
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;进行dns查询&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;fping -a -d 2 &amp;gt; /dev/null  &amp;lt; ip.list
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;lftp&lt;/h3&gt;
&lt;p&gt;基本用法&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;lftp username@ftphost
cd dir
lcd改变本地主机目录
mkdir 创建目录
get/put 下载上传
quit退出
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;scp&lt;/h3&gt;
&lt;p&gt;scp是 secure copy的缩写, scp是linux系统下基于ssh登陆进行安全的远程文件拷贝命令。&lt;/p&gt;
&lt;p&gt;linux的scp命令可以在linux服务器之间复制文件和目录.&lt;/p&gt;
&lt;p&gt;拷贝文件&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;scp filename user@remotehost:/home/pat
ip或主机名均可

scp SOURCE DESTINATION
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;递归复制&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;scp -r dir1 user@remotehost:/home/backup
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;提高拷贝速度&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;scp  -c arcfour -r -P20755 dir/ 192.168.2.*:/**/**/data/
-c arcfour 这个算法没有加校验不保证完整性，注意慎用，内网1000M带宽，默认算法速度只能达到30M/s，用arcfour这个算法速度可以达到50-80M/s
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;SSH&lt;/h3&gt;
&lt;p&gt;连接远程&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;ssh username@remote_host

ssh -p port username@remote_host
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;执行命令&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;ssh username@remote_host &amp;#39;cmd1; cmd2&amp;#39; &amp;gt; stdout.txt 2&amp;gt;errors.txt
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;压缩功能&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;ssh -C user@hostname &amp;#39;cmds&amp;#39;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;打通ssh&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;1.创建SSH密钥
  ssh-keygen -t rsa
  公钥, ~/.ssh/id_rsa.pub
2.登陆远端服务器, 将公钥写入 ~/.ssh/authorized_keys
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;lsof&lt;/h3&gt;
&lt;p&gt;列出系统中开放端口及运行在端口上的服务&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;lsof -i
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;配合grep, 获取需要的信息&lt;/p&gt;
&lt;h3&gt;netstat&lt;/h3&gt;
&lt;p&gt;查看开放端口和服务&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;netstat -tnp
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;磁盘和系统&lt;/h2&gt;
&lt;h3&gt;du&lt;/h3&gt;
&lt;p&gt;du = disk usage&lt;/p&gt;
&lt;p&gt;估计文件的空间占用。 逐层统计文件（例如以递归方式）并输出摘要。&lt;/p&gt;
&lt;p&gt;查看占用磁盘空间&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;du FILENAME1 FILENAME2
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;查看目录&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;du -a dir
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;以KB,MB或块为单位展示&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;du -h FILENAME1
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;显示总计情况&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;du -c FILENAME1
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;只显示合计&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;du -s FILENAME1
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;以特定单位打印&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;du -b/-k/-m/-B FILES
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;排除部分文件&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;du --exclude &amp;quot;*.txt&amp;quot; DIR
   --exclude-from EXCLUDE.txt DIR
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;指定最深层级&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;du --max-depth 2 DIR
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;指定目录最大的10个文件&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;du -ak S_DIR | sort -nrk 1 | head
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;df&lt;/h3&gt;
&lt;p&gt;df = disk free&lt;/p&gt;
&lt;p&gt;报告系统的磁盘使用情况。在跟踪磁盘使用情况方面对于普通用户和系统管理员都很有用。 ‘df‘ 通过检查目录大小工作，但这一数值仅当文件关闭时才得到更新。&lt;/p&gt;
&lt;p&gt;查看磁盘可用空间&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;df
df -h
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;time&lt;/h3&gt;
&lt;p&gt;计算命令执行时间&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;time COMMAND

real 挂钟时间, 从开始执行到结束的时间
user 进程花费在用户模式中的cpu时间, 真正用于执行进程所花得时间
sys  进程花费在内核模式中的cpu时间
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;写入文件&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;time -o output.txt COMMAND
time -a output.txt COMMAND #追加
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;格式化输出&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;time -f &amp;quot;Time: %U&amp;quot;  -a -o timing.log uname
real %e
user %U
sys %S
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;who&lt;/h3&gt;
&lt;p&gt;获取当前用户登陆信息&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;who / w
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;当前登陆主机的用户列表&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;users
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;uptime&lt;/h3&gt;
&lt;p&gt;查看系统已经通电运行多长时间了&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;uptime
#也可以看到负载
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;last&lt;/h3&gt;
&lt;p&gt;显示上次用户登录信息- 前一次启动会话信息&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;last
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;获取单个用户&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;last USER
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;watch&lt;/h3&gt;
&lt;p&gt;在终端中以固定间隔监视命令输出&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;#default 2s
watch ls

# 5s
watch -n 5 ls
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;颜色标示&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;watch -d &amp;#39;COMMAND&amp;#39;
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;进程和线程&lt;/h2&gt;
&lt;h3&gt;ps&lt;/h3&gt;
&lt;p&gt;ps命令给出正在运行的某个进程的状态，每个进程有特定的id成为PID。&lt;/p&gt;
&lt;p&gt;ps命令主要查看系统中进程的状态&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;USER              PID  %CPU %MEM      VSZ    RSS   TT  STAT STARTED      TIME COMMAND
USER表示启动进程用户
PID表示进程标志号

%CPU表示运行该进程占用CPU的时间与该进程总的运行时间的比例
%MEM表示该进程占用内存和总内存的比例。

VSZ表示占用的虚拟内存大小，以KB为单位。
RSS为进程占用的物理内存值，以KB为单位。

TTY表示该进程建立时所对应的终端，&amp;quot;?&amp;quot;表示该进程不占用终端。
STAT表示进程的运行状态，包括以下几种代码：
    D，不可中断的睡眠；
    R，就绪（在可运行队列中）；
    S，睡眠；
    T，被跟踪或停止；
    Z，终止（僵死）的进程，Z不存在，但暂时无法消除；
    W，没有足够的内存分页可分配；&amp;lt;高优先序的进程；
    N，低优先序的进程；
    L，有内存分页分配并锁在内存体内（实时系统或I/O）。

START为进程开始时间。
TIME为执行的时间。
COMMAND是对应的命令名。
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;查看进程信息&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;#当前终端
ps

PID TTY TIME CMD
PID  进程ID
TTY  终端
TIME 进程启动后过去的时间
CMD  进程对应的命令
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;显示更多信息&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;#当前终端
ps -f
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;查看所有进程&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;ps aux
ps -ef
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;查看某个用户的所有进程&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;ps U ken
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;命令格式&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="n"&gt;ps&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;OTHER&lt;/span&gt; &lt;span class="n"&gt;OPTIONS&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;o&lt;/span&gt; &lt;span class="n"&gt;par1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;par2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;par3&lt;/span&gt;
&lt;span class="n"&gt;ps&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;eo&lt;/span&gt; &lt;span class="n"&gt;comm&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;pcpu&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="n"&gt;head&lt;/span&gt;
&lt;span class="n"&gt;pmem&lt;/span&gt; &lt;span class="err"&gt;内存使用率，&lt;/span&gt;&lt;span class="n"&gt;comm&lt;/span&gt;&lt;span class="err"&gt;可执行文件名&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;user&lt;/span&gt;&lt;span class="err"&gt;启动进程的用户&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;etime&lt;/span&gt;&lt;span class="err"&gt;启动后度过的时间&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;设置升序降序&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;ps -eo comm,pcpu --sort -pcpu | head
+升序，-降序
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;找出给定命令名对应进程ID&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;ps -C COMMAND_NAME
ps -C bash -o pid=
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;进程线程相关&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;ps -eLf --sort -nlwp | head
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;查看子进程树&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;ps axwef
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;注意：当你要知道有哪些进程在运行或者需要知道想杀死的进程PID时ps命令很管用。你可以把它与‘grep‘合用来查询指定的输出结果，例如：&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;# ps -A | grep -i ssh
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;pgrep&lt;/h3&gt;
&lt;p&gt;pgrep只需要命令名的一部分, ps需要准确的全名&lt;/p&gt;
&lt;p&gt;基本用法&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;pgrep bash
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;指定进程的用户&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;pgrep -u root,slynux COMMAND
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;返回匹配进程数&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;pgrep -c COMANND
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;top&lt;/h3&gt;
&lt;p&gt;查看占用cpu最多的进程列表&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;top
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;kill&lt;/h3&gt;
&lt;p&gt;kill是用来杀死已经无关紧要或者没有响应的进程,杀死一个进程需要知道进程的PID&lt;/p&gt;
&lt;p&gt;列出可用信号&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;kill -l
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;终止一个进程&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;kill PROCESS_ID_LIST
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;强杀进程&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;kill -9 PROCESS_ID
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;杀死一组命令&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;killall process_name
killall -9 process_name

指定用户
killall -u USERNAME process_name
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;pkill&lt;/h3&gt;
&lt;p&gt;杀，接受进程名&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;pkill process_name
pkill -s SIGNAL process_name
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;which&lt;/h3&gt;
&lt;p&gt;查找PATH下某个命令位置&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;which ls
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;whereis&lt;/h3&gt;
&lt;p&gt;whereis的作用是用来定位命令的二进制文件\资源\或者帮助页.举例来说,获得ls和kill命令的二进制文件/资源以及帮助页:&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;whereis ls
whereis kill
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;类似which，多了命令手册位置，源代码位置&lt;/p&gt;
&lt;p&gt;注意:当需要知道二进制文件保存位置时有用.&lt;/p&gt;
&lt;h3&gt;file&lt;/h3&gt;
&lt;p&gt;确定文件类型&lt;/p&gt;
&lt;h3&gt;whatis&lt;/h3&gt;
&lt;p&gt;对命令的简短描述&lt;/p&gt;
&lt;h3&gt;hostname&lt;/h3&gt;
&lt;p&gt;当前主机名&lt;/p&gt;
&lt;h3&gt;uname&lt;/h3&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;主机名
uname -n

#内核版本，硬件架构等
uname -a

#内核发行版本
uname -r

主机类型(32位/64位)
uname -m

cpu相关信息
cat /proc/cpuinfo

内存信息
cat /proc/meminfo
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;例子&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;#uname -a
Linux tecmint 3.8.0-19-generic #30-Ubuntu SMP Wed May 1 16:36:13 UTC 2013 i686 i686 i686 GNU/Linux

1. “Linux“: 机器的内核名
2. “tecmint“: 机器的分支名
3. “3.8.0-19-generic“: 内核发布版本
4. “#30-Ubuntu SMP“: 内核版本
5. “i686“: 处理器架构
6. “GNU/Linux“: 操作系统名
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;crontab&lt;/h3&gt;
&lt;p&gt;格式&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;* * * * * cmd
分钟(0-59)，小时(0-23)，天(1-31)，月份(1-12)，工作日(0-6)

A,B  A and B
*/C  every C
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;查看&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;crontab -l
crontab -l -u slynux
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;编辑&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;crontab -e
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;移除&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;crontab -r
crontab -u slynux -r
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;可以在crontab 中加入环境变量&lt;/p&gt;
&lt;h3&gt;getopts&lt;/h3&gt;
&lt;p&gt;命令行参数处理&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="x"&gt;while getopts :f:vql opt&lt;/span&gt;
&lt;span class="x"&gt;do&lt;/span&gt;
&lt;span class="x"&gt;    case &lt;/span&gt;&lt;span class="p"&gt;$&lt;/span&gt;&lt;span class="nv"&gt;opt&lt;/span&gt;&lt;span class="x"&gt; in&lt;/span&gt;
&lt;span class="x"&gt;    f)  file=&lt;/span&gt;&lt;span class="p"&gt;$&lt;/span&gt;&lt;span class="nv"&gt;OPTARG&lt;/span&gt;&lt;span class="x"&gt;&lt;/span&gt;
&lt;span class="x"&gt;        ;;&lt;/span&gt;
&lt;span class="x"&gt;    v)  verbose=true&lt;/span&gt;
&lt;span class="x"&gt;        ;;&lt;/span&gt;
&lt;span class="x"&gt;    ....&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;history&lt;/h3&gt;
&lt;p&gt;“history”命令就是历史记录。它显示了在终端中所执行过的所有命令的历史&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;history
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;注意：按住“CTRL + R”就可以搜索已经执行过的命令，它可以你写命令时自动补全&lt;/p&gt;
&lt;h3&gt;sudo&lt;/h3&gt;
&lt;p&gt;“sudo”(super user do)命令允许授权用户执行超级用户或者其它用户的命令。通过在sudoers列表的安全策略来指定。&lt;/p&gt;
&lt;p&gt;注意：sudo 允许用户借用超级用户的权限，然而”su”命令实际上是允许用户以超级用户登录。所以sudo比su更安全。
并不建议使用sudo或者su来处理日常用途，因为它可能导致严重的错误如果你意外的做错了事，这就是为什么在linux社区流行一句话：&lt;/p&gt;
&lt;p&gt;“To err is human, but to really foul up everything, you need root password.”
“人非圣贤孰能无过，但是拥有root密码就真的万劫不复了。”&lt;/p&gt;
&lt;h3&gt;cal&lt;/h3&gt;
&lt;p&gt;“cal”（Calender），它用来显示当前月份或者未来或者过去任何年份中的月份&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;cal
cal 02 1835
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;cp&lt;/h3&gt;
&lt;p&gt;“copy”就是复制。它会从一个地方复制一个文件到另外一个地方&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;cp file1 file2
cp -r dir1 dir2
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;快速备份一个文件：&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;cp some_file_name{,.bkp}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;注意： cp，在shell脚本中是最常用的一个命令，而且它可以使用通配符（在前面一块中有所描述），来定制所需的文件的复制。&lt;/p&gt;
&lt;h3&gt;mv&lt;/h3&gt;
&lt;p&gt;“mv”命令将一个地方的文件移动到另外一个地方去。&lt;/p&gt;
&lt;p&gt;“mv”命令将一个地方的文件移动到另外一个地方去。&lt;/p&gt;
&lt;h3&gt;pwd&lt;/h3&gt;
&lt;p&gt;“pwd”（print working directory），在终端中显示当前工作目录的全路径。&lt;/p&gt;
&lt;p&gt;注意： 这个命令并不会在脚本中经常使用，但是对于新手，当从连接到nux很久后在终端中迷失了路径，这绝对是救命稻草。&lt;/p&gt;
&lt;h3&gt;free&lt;/h3&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;free -m
             total       used       free     shared    buffers     cached
Mem:          7982       6811       1171          0        350       5114
-/+ buffers/cache:       1346       6636
Swap:        16935         11      16924
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;显示剩余内存&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;free -m | grep cache | awk &amp;#39;/[0-9]/{ print $4&amp;quot; MB&amp;quot; }&amp;#39;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;在这里例子中,应用程序只使用了1346MB内存,还有6636MB空闲内存可以使用.&lt;/p&gt;
&lt;p&gt;一些简单的计算方法：&lt;/p&gt;
&lt;p&gt;物理已用内存 = 实际已用内存 - 缓冲 - 缓存 = 6811M - 350M - 5114M&lt;/p&gt;
&lt;p&gt;物理空闲内存 = 总物理内存 - 实际已用内存 + 缓冲 + 缓存&lt;/p&gt;
&lt;p&gt;应用程序可用空闲内存 = 总物理内存 - 实际已用内存&lt;/p&gt;
&lt;p&gt;应用程序已用内存 = 实际已用内存 - 缓冲 - 缓存&lt;/p&gt;
&lt;p&gt;原始解释：转至互联网：
Linux的基本原则是没有资源应该被浪费.因此核心会使用尽可能多的RAM,来缓存来自本地和远程的文件系统的信息.系统做读写操作的时候,会将与当前运行的进程相关的数据尽量存储在RAM里.系统报告的缓存是缓冲和页缓存两者之和.缓存并不是在进程结束的时候被回收(你可能很快会启动另外一个进程,需要同样的数据),而是随需回收–比如,当你启动一个需要大量内存的进程时,Linux核心会从内存中回收缓存,将得到的内存分配给新的进程.&lt;/p&gt;
&lt;p&gt;有些区域,比如匿名内存映射(mmps)和共享内存区域,它们被报告为缓存,但不是被核心直接释放.一般的缓存不映射到进程的地址空间,仅仅是简单的核心映射,而这些特别的缓存映射到所有挂接到它们上面的进程.&lt;/p&gt;
&lt;h3&gt;eval&lt;/h3&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;eval &amp;quot;ls -l&amp;quot;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;basename&lt;/h3&gt;
&lt;p&gt;获取路径中文件部分&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;basename resolv.conf #resolv.conf
basename /etc/resolv.conf # resolv.conf
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;cmp&lt;/h3&gt;
&lt;p&gt;比较两个任意类型的文件并将结果输出至标准输出。如果两个文件相同， ‘cmp‘默认返回0；如果不同，将显示不同的字节数和第一处不同的位置。&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;cmp file1 file2
diff file1 file2
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;rm&lt;/h3&gt;
&lt;p&gt;‘rm’ 标准移除命令。 rm 可以用来删除文件和目录&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;rm file1
rm -r dir1  #递归删除空目录
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;强删&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;rm -rf fileordir
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;警告: ”rm -rf” 命令是一个破坏性的命令,假如你不小心删除一个错误的目录。
一旦你使用’rm -rf’ 删除一个目录,在目录中所有的文件包括目录本身会被永久的删除,所以使用这个命令要非常小心。&lt;/p&gt;
&lt;h3&gt;service&lt;/h3&gt;
&lt;p&gt;‘service‘命令控制服务的启动、停止和重启，它让你能够不重启整个系统就可以让配置生效以开启、停止或者重启某个服务。&lt;/p&gt;
&lt;p&gt;注意：要想使用service命令，进程的脚本必须放在‘/etc/init.d‘，并且路径必须在指定的位置。
如果要运行“service apache2 start”实际上实在执行“service /etc/init.d/apache2 start”.&lt;/p&gt;
&lt;h3&gt;man&lt;/h3&gt;
&lt;p&gt;‘man‘是系统帮助页。Man提供命令所有选项及用法的在线文档。几乎所有的命令都有它们的帮助页&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;man thecommand
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;注意：系统帮助页是为了命令的使用和学习而设计的。&lt;/p&gt;
&lt;h3&gt;passwd&lt;/h3&gt;
&lt;p&gt;这是一个很重要的命令，在终端中用来改变自己密码很有用。显然的，因为安全的原因，你需要知道当前的密码。&lt;/p&gt;
&lt;h3&gt;gcc&lt;/h3&gt;
&lt;p&gt;gcc 是Linux环境下C语言的内建编译器。下面是一个简单的C程序，在桌面上保存为Hello.c （记住必须要有‘.c‘扩展名&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;gcc Hello.c
./a.out
gcc -o Hello Hello.c
./Hello
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;注意: 编译C程序时，输出会自动保存到一个名为“a.out”的新文件，因此每次编译C程序 “a.out”都会被修改。
因此编译期间最好定义输出文件名.，这样就不会有覆盖输出文件的风险了。&lt;/p&gt;
&lt;h3&gt;g++&lt;/h3&gt;
&lt;p&gt;g++是C++的内建编译器&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;g++ Add.cpp
./a.out
g++ -o Add Add.cpp
./Add
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;java&lt;/h3&gt;
&lt;p&gt;Java 是世界上使用最广泛的编程语言之一. 它也被认为是高效, 安全和可靠的编程语言. 现在大多数基于网络的服务都使用Java实现.&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;javac tecmint.java
java tecmint
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;注意: 几乎所有的Linux发行版都带有gcc编译器, 大多数发行版都内建了g++ 和 java 编译器, 有些也可能没有. 你可以用apt 或 yum 安装需要的包.&lt;/p&gt;
&lt;h3&gt;关于/dev/null&lt;/h3&gt;
&lt;p&gt;特别有用的特殊文件，位桶，传送到此文件的数据都会被系统丢弃。&lt;/p&gt;
&lt;h3&gt;语言及乱码&lt;/h3&gt;
&lt;p&gt;查看变量值&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="x"&gt;echo &lt;/span&gt;&lt;span class="p"&gt;$&lt;/span&gt;&lt;span class="nv"&gt;LANG&lt;/span&gt;&lt;span class="x"&gt;   未设置任何LC_XXX时使用的默认值&lt;/span&gt;
&lt;span class="x"&gt;echo &lt;/span&gt;&lt;span class="p"&gt;$&lt;/span&gt;&lt;span class="nv"&gt;LC_ALL&lt;/span&gt;&lt;span class="x"&gt; 覆盖所有LC_XXX变量，总控开关&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;好的做法是，避免为任何LC_XXX变量赋值，使用LC_ALL和LANG来控制&lt;/p&gt;
&lt;p&gt;避免乱码：从编辑器到语言，再到系统，统一编码为UTF-8&lt;/p&gt;
&lt;h3&gt;shell的版本&lt;/h3&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;bash --version
&lt;/pre&gt;&lt;/div&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">wklken</dc:creator><pubDate>Thu, 04 Jul 2013 00:00:00 +0800</pubDate><guid>tag:www.wklken.me,2013-07-04:posts/2013/07/04/note-of-linux-shell-scripting-cookbook.html</guid><category>linux</category><category>shell</category></item><item><title>如何进行shell脚本正确性测试</title><link>http://www.wklken.me/posts/2012/09/15/how-to-test-shell.html</link><description>&lt;p&gt;在实际工作中，需要对shell脚本进行正确性测试。&lt;/p&gt;
&lt;p&gt;如何用最快最有效的方式进行测试？&lt;/p&gt;
&lt;p&gt;很多开发的习惯是，二话不说，写完/拿到，就跑一把，看看输入，输出，想要的操作是否完成，也就过了。&lt;/p&gt;
&lt;p&gt;其实这是十分不严谨的，若是未经过QA，风险还是相当大的。&lt;/p&gt;
&lt;p&gt;以下即shell脚本测试流程，仅供参考&lt;/p&gt;
&lt;p&gt;1.代码走读：&lt;/p&gt;
&lt;p&gt;写完，或者拿到一个shell脚本，不必急于运行，虽然实践是检验整理的唯一标准，但是，在读代码这个过程中，可以规避很多低级的bug.&lt;/p&gt;
&lt;p&gt;读什么？&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;A.代码逻辑，这个脚本用来做什么，主要分为多少步，分别做了什么事情？
  用于检查是否有遗漏逻辑，或有悖于需求。
B.具体语法，变量，判断语句
  语法方面的东西，变量是否定义，判断语句逻辑是否正确，是否考虑各种异常，错误是否退出，返回正确状态值等。
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;2.语法检测：&lt;/p&gt;
&lt;p&gt;shell的语法还是相当让人无语的，很多很容易疏忽遗漏的地方&lt;/p&gt;
&lt;p&gt;命令格式：&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;sh -n ***.sh
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;若是没有异常输出，证明脚本没有明显的语法问题。&lt;/p&gt;
&lt;p&gt;&lt;img alt="运行结果" src="https://github.com/wklken/gallery/blob/master/shell_test/shell_test_1.jpg?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;3.运行跟踪：&lt;/p&gt;
&lt;p&gt;实践是检验整理的唯一标准，跑一把。&lt;/p&gt;
&lt;p&gt;不过，可不是直接运行然后去看最终结果，这样会遗漏掉很多中间过程。&lt;/p&gt;
&lt;p&gt;命令格式:&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;sh -vx ***.sh
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;得到效果如下:&lt;/p&gt;
&lt;p&gt;&lt;img alt="运行结果" src="https://github.com/wklken/gallery/blob/master/shell_test/shell_test_2.jpg?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;我们可以看到&lt;/p&gt;
&lt;p&gt;每行代码原始命令（无+的）:[这是-v的效果]&lt;/p&gt;
&lt;p&gt;代码执行时的情况（带+），包括运算结果，逻辑判断结果，变量赋值等等[-x的效果]&lt;/p&gt;
&lt;p&gt;而我们所要关注的就是这些信息，主要是变量值和逻辑判断结果。&lt;/p&gt;
&lt;p&gt;4.覆盖分支：&lt;/p&gt;
&lt;p&gt;直接跑，只能覆盖到主体流程，对于其他控制流分支的代码是无法覆盖到的。&lt;/p&gt;
&lt;p&gt;对于关键性的，重点的逻辑，我们需要制造条件，使运行脚本可以进入对应分支&lt;/p&gt;
&lt;p&gt;5.其他：&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;A.关于bashdb:
  可以尝试下，但是感觉投入产出比不高
B.关于单元测试：
  实际工作中，由于项目压力比较大，单元测试的成本还是相当高的，所以目前为止没有。
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;6.有没有更好的方式?&lt;/p&gt;
&lt;p&gt;好吧，单步跟踪，脚本短的还好，日志信息不会太多，要是多了，存在调用其他脚本等等.....&lt;/p&gt;
&lt;p&gt;日志量达到几千行，这是很轻易的事情。&lt;/p&gt;
&lt;p&gt;跟踪过的童鞋有同感，展现不够友好，惨白惨白一片，一千行下来，看的眼花。&lt;/p&gt;
&lt;p&gt;很容易遗漏（LZ被坑了好多回，你看，或不看......错误信息明明就在那里，就是视而不见）&lt;/p&gt;
&lt;p&gt;So.进行了一层优化，对日志进行处理，使用正则，标注我关心的信息&lt;/p&gt;
&lt;p&gt;效果图对比：&lt;/p&gt;
&lt;p&gt;&lt;img alt="原始图" src="https://github.com/wklken/gallery/blob/master/shell_test/shell_test_3.jpg?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="扩展图" src="https://github.com/wklken/gallery/blob/master/shell_test/shell_test_4.jpg?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;脚本是用python实现的，位置:https://github.com/wklken/pytools/tree/master/shell&lt;/p&gt;
&lt;p&gt;思想是：执行，抓到所有日志，用正则进行匹配，打上颜色，然后输出&lt;/p&gt;
&lt;p&gt;好了，就这些&lt;/p&gt;
&lt;p&gt;工具的实现是为了提高效率，节约时间。&lt;/p&gt;
&lt;p&gt;The end!&lt;/p&gt;
&lt;p&gt;wklken&lt;/p&gt;
&lt;p&gt;Gighub: https://github.com/wklken&lt;/p&gt;
&lt;p&gt;Blog: http://wklken.me&lt;/p&gt;
&lt;p&gt;2012-09-15&lt;/p&gt;
&lt;p&gt;转载请注明出处，谢谢！&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">wklken</dc:creator><pubDate>Sat, 15 Sep 2012 00:00:00 +0800</pubDate><guid>tag:www.wklken.me,2012-09-15:posts/2012/09/15/how-to-test-shell.html</guid><category>python</category><category>shell</category></item></channel></rss>