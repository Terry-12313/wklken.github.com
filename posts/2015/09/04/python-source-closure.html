<!DOCTYPE html>
<html lang="en">

<!--[if IE 8]> <html class="no-js lt-ie9" lang="en"> <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en"> <!--<![endif]-->

<head>
    <meta name="google-site-verification" content="SzE6WCs23qFevgBzRIuG9vcfLU0lW_Vd5hFT-cJOLBE" />
    <title>Python源码阅读-闭包的实现</title>
    <meta charset="utf-8" />
    <meta name="description" content="">
    <meta name="keywords" content="" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">

        <link rel="shortcut icon" href="/favicon.ico"/>
        <link rel="stylesheet" href="/theme/css/styles.css" media="all" />
        <link rel="stylesheet" href="/theme/css/tab.min.css" media="all" />
        <link rel="stylesheet" href="/theme/css/jquery-ui.min.css" media="all" />

        <link rel="stylesheet" href="/theme/css/font-awesome.min.css">
        <!--
        <link rel="stylesheet" href="http://apps.bdimg.com/libs/fontawesome/4.2.0/css/font-awesome.min.css">
        -->
        <!--[if IE 7]>
            <link rel="stylesheet" href="/theme/css/font-awesome-ie7.min.css">
        <![endif]-->

        <link href="/" type="application/atom+xml" rel="alternate" title="wklken's blog ATOM Feed" />
        <link href="/feed.xml" type="application/atom+xml" rel="alternate" title="wklken's blog RSS Feed" />

</head>

<body id="index" class="home">
    <div id="page" class="row">
        <div class="large-9 large-centered columns">

        <header id="header">
            <div class="constraint">
                <div class="o">
                    <a href="/"><h1 class="banner">Wklken <span class="blue"> Building </span></h1></a>

                <div class="social">
                            <a href="https://github.com/wklken" target='_blank'><i class="icon-github-sign icon-2x"></i></a>
                            <a href="http://weibo.com/wklken" target='_blank'><i class="icon-weibo icon-2x"></i></a>
                            <a href="mailto:wklken@yeah.net"><i class="icon-envelope icon-2x"></i></a>
                            <a href="http://www.wklken.me/feed.xml" target='_blank'><i class="icon-rss-sign icon-2x"></i></a>
                </div>
                <div class="nav">
                            <a href="/">首页</a>
                            <a href="/categories.html">分类</a>
                            <a href="/archives.html">归档</a>
                            <a href="/pages/projects.html">项目</a>
                            <a href="/pages/aboutme.html">关于</a>

                </div>

                </div>
            </div>
        </header><!-- /#banner -->

        <section id="main">


<article id="article">
    <section id="header">
        <!--
        <div class="meta">2015年09月04日</div>
        <h1 id="title"> Python源码阅读-闭包的实现 </h1>
        -->
        <div class="meta"> &nbsp; </div>
        <h1> Python源码阅读-闭包的实现 </h1>
    </section>

        <section id="toc">
            <html><body><div id="toc"><ul><li><a class="toc-href" href="#" title="Python源码阅读-闭包的实现">Python源码阅读-闭包的实现</a><ul><li><a class="toc-href" href="#_1" title="闭包">闭包</a></li><li><a class="toc-href" href="#pycodeobject" title="PyCodeObject">PyCodeObject</a></li><li><a class="toc-href" href="#pycellobject" title="PyCellObject">PyCellObject</a></li><li><a class="toc-href" href="#_2" title="值的确认与传递过程">值的确认与传递过程</a></li><li><a class="toc-href" href="#pyframeobject" title="看看PyFrameObject">看看PyFrameObject</a></li><li><a class="toc-href" href="#f_localsplus" title="示例函数的f_localsplus">示例函数的f_localsplus</a></li><li><a class="toc-href" href="#_3" title="传递">传递</a></li><li><a class="toc-href" href="#_4" title="然后, 在嵌套函数被调用的时候">然后, 在嵌套函数被调用的时候</a></li><li><a class="toc-href" href="#dis" title="最后, 再来看一个闭包的dis">最后, 再来看一个闭包的dis</a></li></ul></li></ul></div></body></html>
        </section>
    <section id="content">
        <h3 id="_1">闭包</h3>
<p>e.g.</p>
<div class="codehilite"><pre>def add(x):
    def do_add(value):
        return x + value
    return do_add

add_5 = add(5)
print add_5(1)  # 6
print add_5(2)  # 7
</pre></div>
<p>需要回答, 什么是闭包, CPython底层是如何实现的?</p>
<h3 id="pycodeobject">PyCodeObject</h3>
<div class="codehilite"><pre>typedef struct <span class="p">{</span>
    PyObject_HEAD
    int co_argcount<span class="p">;</span>        <span class="o">/*</span> <span class="c1">#arguments, except *args */</span>
    int co_nlocals<span class="p">;</span>         <span class="o">/*</span> <span class="c1">#local variables */</span>
    int co_stacksize<span class="p">;</span>       <span class="o">/*</span> <span class="c1">#entries needed for evaluation stack */</span>
    int co_flags<span class="p">;</span>           <span class="o">/*</span> CO_...<span class="p">,</span> see below <span class="o">*/</span>
    PyObject <span class="o">*</span>co_code<span class="p">;</span>      <span class="o">/*</span> instruction opcodes <span class="o">*/</span>
    PyObject <span class="o">*</span>co_consts<span class="p">;</span>    <span class="o">/*</span> <span class="kt">list</span> <span class="p">(</span>constants used<span class="p">)</span> <span class="o">*/</span>
    PyObject <span class="o">*</span>co_names<span class="p">;</span>     <span class="o">/*</span> <span class="kt">list</span> of strings <span class="p">(</span>names used<span class="p">)</span> <span class="o">*/</span>
    PyObject <span class="o">*</span>co_varnames<span class="p">;</span>  <span class="o">/*</span> tuple of strings <span class="p">(</span>local variable <span class="kp">names</span><span class="p">)</span> <span class="o">*/</span>

    <span class="o">//</span> 保存使用了的外层作用域中的变量名集合 <span class="p">(</span>编译时就知道的<span class="o">!</span> 被嵌套的时候有用<span class="p">)</span>
    PyObject <span class="o">*</span>co_freevars<span class="p">;</span>  <span class="o">/*</span> tuple of strings <span class="p">(</span>free variable <span class="kp">names</span><span class="p">)</span> <span class="o">*/</span>
    <span class="o">//</span> 保存嵌套作用域中使用的变量名集合<span class="p">,</span> <span class="p">(</span>编译时就知道的<span class="o">!</span> 包含嵌套函数时有用<span class="p">)</span>
    PyObject <span class="o">*</span>co_cellvars<span class="p">;</span>      <span class="o">/*</span> tuple of strings <span class="p">(</span>cell variable <span class="kp">names</span><span class="p">)</span> <span class="o">*/</span>


    <span class="o">/*</span> The rest doesn<span class="s">'</span><span class="err">t count for hash/cmp */</span>
    PyObject <span class="o">*</span>co_filename<span class="p">;</span>  <span class="o">/*</span> string <span class="p">(</span>where it was loaded from<span class="p">)</span> <span class="o">*/</span>
    PyObject <span class="o">*</span>co_name<span class="p">;</span>      <span class="o">/*</span> string <span class="p">(</span>name<span class="p">,</span> <span class="kr">for</span> reference<span class="p">)</span> <span class="o">*/</span>
    int co_firstlineno<span class="p">;</span>     <span class="o">/*</span> first <span class="kn">source</span> line number <span class="o">*/</span>
    PyObject <span class="o">*</span>co_lnotab<span class="p">;</span>    <span class="o">/*</span> string <span class="p">(</span>encoding addr<span class="o">&lt;-&gt;</span>lineno mapping<span class="p">)</span> See
                   Objects<span class="o">/</span>lnotab_notes.txt <span class="kr">for</span> details. <span class="o">*/</span>
    void <span class="o">*</span>co_zombieframe<span class="p">;</span>     <span class="o">/*</span> <span class="kr">for</span> optimization only <span class="p">(</span>see frameobject.c<span class="p">)</span> <span class="o">*/</span>
    PyObject <span class="o">*</span>co_weakreflist<span class="p">;</span>   <span class="o">/*</span> to support weakrefs to code objects <span class="o">*/</span>
<span class="p">}</span> PyCodeObject<span class="p">;</span>
</pre></div>
<p>我们关注两个, <code>co_freevars</code> 和 <code>co_cellvars</code></p>
<div class="codehilite"><pre>co_freevars, 保存使用了的外层作用域中的变量名集合 (编译时就知道的! 被嵌套的时候有用)

co_cellvars, 保存嵌套作用域中使用的变量名集合, (编译时就知道的! 包含嵌套函数时有用)
</pre></div>
<p>对于我们上面的那个示例, <code>add</code>是外层函数, <code>do_add</code>是嵌套函数, 我们可以通过<code>func_code</code>打印看看</p>
<div class="codehilite"><pre>def add(x):    # 外层函数
    # 外层函数, 没有使用了外层作用域变量, 被嵌套函数使用了'x'
    print add.func_code.co_freevars    # ()
    print add.func_code.co_cellvars    # ('x',)

    def do_add(value):  # 嵌套函数
        return x + value

    # 内层函数, 使用了外层作用域便令'x', 没有嵌套函数故嵌套作用域变量名集合空
    print do_add.func_code.co_freevars # ('x',)
    print do_add.func_code.co_cellvars # ()
    return do_add
</pre></div>
<p>此时图示</p>
<p><img alt="closure" src="/imgs/python-source/python-closure.png"/></p>
<p>这时候, 只是记录了使用到的变量名, 标记下是否使用了外层的/被内层使用的变量</p>
<p>具体的值是在运行时确定的, 例如</p>
<div class="codehilite"><pre>add(5)
</pre></div>
<p>此时<code>x=5</code>, 这个是在<code>add</code>的名字空间里面的, 那么, <code>x=5</code>是怎么传递到嵌套函数内? 嵌套函数又是如何知晓<code>x</code>的值?</p>
<p>记住这两个问题, 然后我们首先来看一个新的数据结构</p>
<h3 id="pycellobject">PyCellObject</h3>
<div class="codehilite"><pre>  typedef struct {
    PyObject_HEAD
    PyObject *ob_ref;   /* Content of the cell or NULL when empty */ =&gt; 指向一个PyObject
  } PyCellObject;


  PyObject *
  PyCell_New(PyObject *obj)
  {
      PyCellObject *op;

      op = (PyCellObject *)PyObject_GC_New(PyCellObject, &amp;PyCell_Type);
      if (op == NULL)
          return NULL;
      op-&gt;ob_ref = obj;  //建立关系
      Py_XINCREF(obj);

      _PyObject_GC_TRACK(op);
      return (PyObject *)op;
  }
</pre></div>
<p>这是个很简单的基本对象, 有一个<code>ob_ref</code>指向另一个<code>PyObject</code>, 仅此而已</p>
<p>图示</p>
<p><img alt="closure" src="/imgs/python-source/python-closure2.png"/></p>
<p>作用呢?</p>
<h3 id="_2">值的确认与传递过程</h3>
<p>调用</p>
<div class="codehilite"><pre>add(5)
</pre></div>
<p>此时, 开始调用函数</p>
<div class="codehilite"><pre><span class="nx">CALL_FUNCTION</span>

<span class="o">=&gt;</span> <span class="nx">x</span> <span class="o">=</span> <span class="nx">call_function</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sp</span><span class="p">,</span> <span class="nx">oparg</span><span class="p">);</span>

<span class="o">=&gt;</span> <span class="nx">x</span> <span class="o">=</span> <span class="nx">fast_function</span><span class="p">(</span><span class="nx">func</span><span class="p">,</span> <span class="nx">pp_stack</span><span class="p">,</span> <span class="nx">n</span><span class="p">,</span> <span class="nx">na</span><span class="p">,</span> <span class="nx">nk</span><span class="p">);</span>

      <span class="k">return</span> <span class="nx">PyEval_EvalCodeEx</span><span class="p">(</span><span class="nx">co</span><span class="p">,</span> <span class="nx">globals</span><span class="p">,</span>
                               <span class="p">(</span><span class="nx">PyObject</span> <span class="o">*</span><span class="p">)</span><span class="nx">NULL</span><span class="p">,</span> <span class="p">(</span><span class="o">*</span><span class="nx">pp_stack</span><span class="p">)</span><span class="o">-</span><span class="nx">n</span><span class="p">,</span> <span class="nx">na</span><span class="p">,</span>
                               <span class="p">(</span><span class="o">*</span><span class="nx">pp_stack</span><span class="p">)</span><span class="o">-</span><span class="mi">2</span><span class="o">*</span><span class="nx">nk</span><span class="p">,</span> <span class="nx">nk</span><span class="p">,</span> <span class="nx">d</span><span class="p">,</span> <span class="nx">nd</span><span class="p">,</span>
                               <span class="nx">PyFunction_GET_CLOSURE</span><span class="p">(</span><span class="nx">func</span><span class="p">));</span>

<span class="o">=&gt;</span>

<span class="nx">PyEval_EvalCodeEx</span>

<span class="nx">add</span><span class="p">(</span><span class="mi">5</span><span class="p">),</span> <span class="nx">此时其co_cellvars</span> <span class="o">=</span> <span class="p">(</span><span class="s1">'x'</span><span class="p">,)</span> <span class="nx">非空</span><span class="p">,</span> <span class="nx">将会执行的逻辑代码</span>


      <span class="cm">/* Allocate and initialize storage for cell vars, and copy free</span>
<span class="cm">         vars into frame.  This isn't too efficient right now. */</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">PyTuple_GET_SIZE</span><span class="p">(</span><span class="nx">co</span><span class="o">-&gt;</span><span class="nx">co_cellvars</span><span class="p">))</span> <span class="p">{</span>
          <span class="kr">int</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">j</span><span class="p">,</span> <span class="nx">nargs</span><span class="p">,</span> <span class="nx">found</span><span class="p">;</span>
          <span class="kr">char</span> <span class="o">*</span><span class="nx">cellname</span><span class="p">,</span> <span class="o">*</span><span class="nx">argname</span><span class="p">;</span>
          <span class="nx">PyObject</span> <span class="o">*</span><span class="nx">c</span><span class="p">;</span>

          <span class="nx">nargs</span> <span class="o">=</span> <span class="nx">co</span><span class="o">-&gt;</span><span class="nx">co_argcount</span><span class="p">;</span>
          <span class="k">if</span> <span class="p">(</span><span class="nx">co</span><span class="o">-&gt;</span><span class="nx">co_flags</span> <span class="o">&amp;</span> <span class="nx">CO_VARARGS</span><span class="p">)</span>
              <span class="nx">nargs</span><span class="o">++</span><span class="p">;</span>
          <span class="k">if</span> <span class="p">(</span><span class="nx">co</span><span class="o">-&gt;</span><span class="nx">co_flags</span> <span class="o">&amp;</span> <span class="nx">CO_VARKEYWORDS</span><span class="p">)</span>
              <span class="nx">nargs</span><span class="o">++</span><span class="p">;</span>

          <span class="cm">/* Initialize each cell var, taking into account</span>
<span class="cm">             cell vars that are initialized from arguments.</span>

<span class="cm">             Should arrange for the compiler to put cellvars</span>
<span class="cm">             that are arguments at the beginning of the cellvars</span>
<span class="cm">             list so that we can march over it more efficiently?</span>
<span class="cm">          */</span>

          <span class="c1">// for 循环遍历 co_cellvars = ('x', ), i = 0</span>
          <span class="k">for</span> <span class="p">(</span><span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">PyTuple_GET_SIZE</span><span class="p">(</span><span class="nx">co</span><span class="o">-&gt;</span><span class="nx">co_cellvars</span><span class="p">);</span> <span class="o">++</span><span class="nx">i</span><span class="p">)</span> <span class="p">{</span>

              <span class="c1">// cellname = 'x'</span>
              <span class="nx">cellname</span> <span class="o">=</span> <span class="nx">PyString_AS_STRING</span><span class="p">(</span>
                  <span class="nx">PyTuple_GET_ITEM</span><span class="p">(</span><span class="nx">co</span><span class="o">-&gt;</span><span class="nx">co_cellvars</span><span class="p">,</span> <span class="nx">i</span><span class="p">));</span>
              <span class="nx">found</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

              <span class="c1">// 遍历函数的参数变量, narg=1, j=0</span>
              <span class="k">for</span> <span class="p">(</span><span class="nx">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">j</span> <span class="o">&lt;</span> <span class="nx">nargs</span><span class="p">;</span> <span class="nx">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>

                  <span class="c1">// 访问当前名字空间</span>
                  <span class="nx">argname</span> <span class="o">=</span> <span class="nx">PyString_AS_STRING</span><span class="p">(</span>
                      <span class="nx">PyTuple_GET_ITEM</span><span class="p">(</span><span class="nx">co</span><span class="o">-&gt;</span><span class="nx">co_varnames</span><span class="p">,</span> <span class="nx">j</span><span class="p">));</span>

                  <span class="c1">// 匹配上了</span>
                  <span class="k">if</span> <span class="p">(</span><span class="nx">strcmp</span><span class="p">(</span><span class="nx">cellname</span><span class="p">,</span> <span class="nx">argname</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>

                      <span class="c1">// new 一个 PyCellObject, ob_ref指向变量的PyObject</span>
                      <span class="nx">c</span> <span class="o">=</span> <span class="nx">PyCell_New</span><span class="p">(</span><span class="nx">GETLOCAL</span><span class="p">(</span><span class="nx">j</span><span class="p">));</span>
                      <span class="k">if</span> <span class="p">(</span><span class="nx">c</span> <span class="o">==</span> <span class="nx">NULL</span><span class="p">)</span>
                          <span class="kr">goto</span> <span class="nx">fail</span><span class="p">;</span>

                      <span class="c1">// #define GETLOCAL(i)     (fastlocals</span><span class="cp">[</span><span class="nx">i</span><span class="cp">]</span><span class="c1">)</span>
                      <span class="c1">// fastlocals = f-&gt;f_localsplus;</span>
                      <span class="c1">// 即 f-&gt;f_localsplus</span><span class="cp">[</span><span class="nx">co</span><span class="o">-&gt;</span><span class="nx-Member">co_nlocals</span> <span class="o">+</span> <span class="nx">i</span><span class="cp">]</span><span class="c1"> = c, 相当于放到下一层freevars变量</span>
                      <span class="nx">GETLOCAL</span><span class="p">(</span><span class="nx">co</span><span class="o">-&gt;</span><span class="nx">co_nlocals</span> <span class="o">+</span> <span class="nx">i</span><span class="p">)</span> <span class="o">=</span> <span class="nx">c</span><span class="p">;</span>
                      <span class="nx">found</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
                      <span class="k">break</span><span class="p">;</span>
                  <span class="p">}</span>
              <span class="p">}</span>

              <span class="c1">// 没有匹配, 给个指向NULL的PyCellObject, 先New一个对象占位</span>
              <span class="k">if</span> <span class="p">(</span><span class="nx">found</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
                  <span class="nx">c</span> <span class="o">=</span> <span class="nx">PyCell_New</span><span class="p">(</span><span class="nx">NULL</span><span class="p">);</span>
                  <span class="k">if</span> <span class="p">(</span><span class="nx">c</span> <span class="o">==</span> <span class="nx">NULL</span><span class="p">)</span>
                      <span class="kr">goto</span> <span class="nx">fail</span><span class="p">;</span>
                  <span class="nx">SETLOCAL</span><span class="p">(</span><span class="nx">co</span><span class="o">-&gt;</span><span class="nx">co_nlocals</span> <span class="o">+</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">c</span><span class="p">);</span> <span class="c1">//注意内存地址</span>
              <span class="p">}</span>
          <span class="p">}</span>
      <span class="p">}</span>
</pre></div>
<p>逻辑即, 如果发现当前函数<code>co_cellvars</code>非空, 即表示存在被内层函数调用的变量, 那么遍历这个<code>co_cellvars</code>集合, 拿到集合中每个变量名在当前名字空间中的值, 然后放到当前函数的<code>f-&gt;f_localsplus</code>中.</p>
<p>这里, 我们可以知道<code>x=5</code>被放进去了</p>
<p>为什么放到<code>f-&gt;f_localsplus</code>中呢?</p>
<h3 id="pyframeobject">看看PyFrameObject</h3>
<div class="codehilite"><pre><span class="nx">typedef</span> <span class="nx">struct</span> <span class="nx">_frame</span> <span class="p">{</span>
    <span class="nx">PyObject_VAR_HEAD</span>
    <span class="nx">struct</span> <span class="nx">_frame</span> <span class="o">*</span><span class="nx">f_back</span><span class="p">;</span>  <span class="cm">/* previous frame, or NULL */</span>
    <span class="nx">PyCodeObject</span> <span class="o">*</span><span class="nx">f_code</span><span class="p">;</span>   <span class="cm">/* code segment */</span>
    <span class="nx">PyObject</span> <span class="o">*</span><span class="nx">f_builtins</span><span class="p">;</span>   <span class="cm">/* builtin symbol table (PyDictObject) */</span>
    <span class="nx">PyObject</span> <span class="o">*</span><span class="nx">f_globals</span><span class="p">;</span>    <span class="cm">/* global symbol table (PyDictObject) */</span>
    <span class="nx">PyObject</span> <span class="o">*</span><span class="nx">f_locals</span><span class="p">;</span>     <span class="cm">/* local symbol table (any mapping) */</span>
    <span class="nx">PyObject</span> <span class="o">**</span><span class="nx">f_valuestack</span><span class="p">;</span>    <span class="cm">/* points after the last local */</span>
    <span class="cm">/* Next free slot in f_valuestack.  Frame creation sets to f_valuestack.</span>
<span class="cm">       Frame evaluation usually NULLs it, but a frame that yields sets it</span>
<span class="cm">       to the current stack top. */</span>
    <span class="nx">PyObject</span> <span class="o">**</span><span class="nx">f_stacktop</span><span class="p">;</span>
    <span class="nx">PyObject</span> <span class="o">*</span><span class="nx">f_trace</span><span class="p">;</span>      <span class="cm">/* Trace function */</span>

    <span class="cm">/* If an exception is raised in this frame, the next three are used to</span>
<span class="cm">     * record the exception info (if any) originally in the thread state.  See</span>
<span class="cm">     * comments before set_exc_info() -- it's not obvious.</span>
<span class="cm">     * Invariant:  if _type is NULL, then so are _value and _traceback.</span>
<span class="cm">     * Desired invariant:  all three are NULL, or all three are non-NULL.  That</span>
<span class="cm">     * one isn't currently true, but "should be".</span>
<span class="cm">     */</span>
    <span class="nx">PyObject</span> <span class="o">*</span><span class="nx">f_exc_type</span><span class="p">,</span> <span class="o">*</span><span class="nx">f_exc_value</span><span class="p">,</span> <span class="o">*</span><span class="nx">f_exc_traceback</span><span class="p">;</span>

    <span class="nx">PyThreadState</span> <span class="o">*</span><span class="nx">f_tstate</span><span class="p">;</span>
    <span class="kr">int</span> <span class="nx">f_lasti</span><span class="p">;</span>        <span class="cm">/* Last instruction if called */</span>
    <span class="cm">/* Call PyFrame_GetLineNumber() instead of reading this field</span>
<span class="cm">       directly.  As of 2.3 f_lineno is only valid when tracing is</span>
<span class="cm">       active (i.e. when f_trace is set).  At other times we use</span>
<span class="cm">       PyCode_Addr2Line to calculate the line from the current</span>
<span class="cm">       bytecode index. */</span>
    <span class="kr">int</span> <span class="nx">f_lineno</span><span class="p">;</span>       <span class="cm">/* Current line number */</span>
    <span class="kr">int</span> <span class="nx">f_iblock</span><span class="p">;</span>       <span class="cm">/* index in f_blockstack */</span>
    <span class="nx">PyTryBlock</span> <span class="nx">f_blockstack</span><span class="cp">[</span><span class="nx">CO_MAXBLOCKS</span><span class="cp">]</span><span class="p">;</span> <span class="cm">/* for try and loop blocks */</span>
    <span class="nx">PyObject</span> <span class="o">*</span><span class="nx">f_localsplus</span><span class="cp">[</span><span class="mi">1</span><span class="cp">]</span><span class="p">;</span>  <span class="cm">/* locals+stack, dynamically sized */</span>
<span class="p">}</span> <span class="nx">PyFrameObject</span><span class="p">;</span>
</pre></div>
<p>注意<code>f_localsplus</code></p>
<div class="codehilite"><pre>f_localsplus为一个PyObject的指针数组，大小为1。

c语言中, 当申请一个大小超过sizeof(PyFrameObject)的结构体对象时，超过的部分就自动分配给f_localsplus
</pre></div>
<p>创建过程</p>
<p>在<code>call_function</code>的时候, <code>new</code>了一个PyFrameObject</p>
<div class="codehilite"><pre>f = PyFrame_New(tstate, co, globals, locals);

=&gt;

PyFrameObject *
PyFrame_New(PyThreadState *tstate, PyCodeObject *code, PyObject *globals,
            PyObject *locals)
{
        Py_ssize_t extras, ncells, nfrees;
        ncells = PyTuple_GET_SIZE(code-&gt;co_cellvars);
        nfrees = PyTuple_GET_SIZE(code-&gt;co_freevars);
        extras = code-&gt;co_stacksize + code-&gt;co_nlocals + ncells +
            nfrees;

=&gt;

f = PyObject_GC_NewVar(PyFrameObject, &amp;PyFrame_Type, extras);
</pre></div>
<p>即</p>
<div class="codehilite"><pre>f_localsplus =&gt; 局部变量 + cell对象 + free对象 + 运行时栈
</pre></div>
<p>原因: 因为函数中的局部变量总是固定不变的, 在编译时就能确定局部变量使用的内存空间的位置, 也能确定访问局部变量的字节码应该如何访问内存, 有了这些信息, Python就能借助静态的方法实现局部变量, 而不是动态查找PyDictObject, 提高执行效率</p>
<p><img alt="closure" src="/imgs/python-source/python-closure3.png"/></p>
<h3 id="f_localsplus">示例函数的f_localsplus</h3>
<p>看一下上面赋值用的宏定义</p>
<div class="codehilite"><pre><span class="x">  </span><span class="n">fastlocals</span><span class="o"> =</span> <span class="nx">f</span><span class="o">-&gt;</span><span class="nx-Member">f_localsplus</span><span class="p">;</span>
  <span class="vi">#define</span> <span class="nx">GETLOCAL</span><span class="p">(</span><span class="nx">i</span><span class="p">)</span>     <span class="p">(</span><span class="nx">fastlocals</span><span class="err">[</span><span class="nx">i</span><span class="cp">]</span><span class="x">)</span>
<span class="x">  #define SETLOCAL(i, value)      do { PyObject *tmp = GETLOCAL(i); \</span>
<span class="x">                                       GETLOCAL(i) = value; \</span>
<span class="x">                                       Py_XDECREF(tmp); } while (0)</span>
</pre></div>
<p>最终得到</p>
<p><img alt="closure" src="/imgs/python-source/python-closure4.png"/></p>
<p>接下去呢? <code>CALL_FUNCTION</code>最后怎么处理将cell传入嵌套函数?</p>
<h3 id="_3">传递</h3>
<p><code>CALL_FUNCTION</code> 完成<code>new</code>一个<code>PyFrameObject</code>之后,</p>
<p>最终执行这个frame</p>
<div class="codehilite"><pre>retval = PyEval_EvalFrameEx(f,0);
</pre></div>
<p>PyEval_EvalFrameEx</p>
<div class="codehilite"><pre>  PyObject *
  PyEval_EvalFrameEx(PyFrameObject *f, int throwflag)
  {

    fastlocals = f-&gt;f_localsplus;
    freevars = f-&gt;f_localsplus + co-&gt;co_nlocals;


=&gt; 此时涉及op_code的执行了
</pre></div>
<p>查看一下dis的结果</p>
<div class="codehilite"><pre>def add(x):
    def do_add(value):
        return x + value
    return do_add

  5           0 LOAD_CLOSURE             0 (x)
              3 BUILD_TUPLE              1
              6 LOAD_CONST               1 (&lt;code object do_add at 0x10c9cec30, file "a.py", line 5&gt;)
              9 MAKE_CLOSURE             0
             12 STORE_FAST               1 (do_add)

  7          15 LOAD_FAST                1 (do_add)
             18 RETURN_VALUE
</pre></div>
<p>首先<code>LOAD_CLOSURE 0</code></p>
<div class="codehilite"><pre>          case LOAD_CLOSURE:
              x = freevars[oparg];
              Py_INCREF(x);
              PUSH(x);
              if (x != NULL) continue;
              break;

入栈, 此时得到一个PyCellObject, 指向2, name='x'

LOAD_CLOSURE 在编译时会根据嵌套函数中 co_freevars, 决定了取得参数位置和个数
</pre></div>
<p>然后, <code>BUILD_TUPLE</code>, 将cell对象打包成tuple, 得到<code>('x', )</code></p>
<p>然后, 开始, 载入嵌套函数<code>do_add</code>, 入栈</p>
<p>调用<code>MAKE_CLOSURE</code></p>
<div class="codehilite"><pre>          case MAKE_CLOSURE:
          {
              v = POP(); /* code object */  // do_add函数
              x = PyFunction_New(v, f-&gt;f_globals); //绑定global名字空间
              // 到这里, 得到一个PyFunctionObject

              Py_DECREF(v);
              if (x != NULL) {
                  v = POP();   // 得到tuple, ('x', )

                  // 注意这里
                  if (PyFunction_SetClosure(x, v) != 0) {
                      /* Can't happen unless bytecode is corrupt. */
                      why = WHY_EXCEPTION;
                  }
                  Py_DECREF(v);
              }
              ......
          }
</pre></div>
<p>来关注一下 <code>PyFunction_SetClosure</code></p>
<div class="codehilite"><pre>int
PyFunction_SetClosure(PyObject *op, PyObject *closure)
{
    ...
    Py_XDECREF(((PyFunctionObject *) op) -&gt; func_closure);
    ((PyFunctionObject *) op) -&gt; func_closure = closure;  // 注意这里
    return 0;
}
</pre></div>
<p>即<code>do_add</code>的 <code>PyFunctionObject</code>的<code>func_closure</code>指向一个tuple</p>
<p>注意: 这时候, 外层变量已经固定下来了!!!!!!</p>
<h3 id="_4">然后, 在嵌套函数被调用的时候</h3>
<div class="codehilite"><pre><span class="nx">CALL_FUNCTION</span>

<span class="o">=&gt;</span>

<span class="nx">x</span> <span class="o">=</span> <span class="nx">call_function</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sp</span><span class="p">,</span> <span class="nx">oparg</span><span class="p">);</span>

<span class="o">=&gt;</span>

<span class="nx">x</span> <span class="o">=</span> <span class="nx">fast_function</span><span class="p">(</span><span class="nx">func</span><span class="p">,</span> <span class="nx">pp_stack</span><span class="p">,</span> <span class="nx">n</span><span class="p">,</span> <span class="nx">na</span><span class="p">,</span> <span class="nx">nk</span><span class="p">);</span>

<span class="o">=&gt;</span>

      <span class="k">return</span> <span class="nx">PyEval_EvalCodeEx</span><span class="p">(</span><span class="nx">co</span><span class="p">,</span> <span class="nx">globals</span><span class="p">,</span>
                               <span class="p">(</span><span class="nx">PyObject</span> <span class="o">*</span><span class="p">)</span><span class="nx">NULL</span><span class="p">,</span> <span class="p">(</span><span class="o">*</span><span class="nx">pp_stack</span><span class="p">)</span><span class="o">-</span><span class="nx">n</span><span class="p">,</span> <span class="nx">na</span><span class="p">,</span>
                               <span class="p">(</span><span class="o">*</span><span class="nx">pp_stack</span><span class="p">)</span><span class="o">-</span><span class="mi">2</span><span class="o">*</span><span class="nx">nk</span><span class="p">,</span> <span class="nx">nk</span><span class="p">,</span> <span class="nx">d</span><span class="p">,</span> <span class="nx">nd</span><span class="p">,</span>
                               <span class="nx">PyFunction_GET_CLOSURE</span><span class="p">(</span><span class="nx">func</span><span class="p">));</span>
</pre></div>
<p>看下<code>PyFunction_GET_CLOSURE</code></p>
<div class="codehilite"><pre>  #define PyFunction_GET_CLOSURE(func) \
      (((PyFunctionObject *)func) -&gt; func_closure)
</pre></div>
<p>然后, 进入 <code>PyEval_EvalCodeEx</code>, 注意这里的<code>closure</code>参数即上一步取出来的<code>func_closure</code>, 即外层函数传进来的tuple</p>
<div class="codehilite"><pre>  PyObject *
  PyEval_EvalCodeEx(PyCodeObject *co, PyObject *globals, PyObject *locals,
             PyObject **args, int argcount, PyObject **kws, int kwcount,
             PyObject **defs, int defcount, PyObject *closure)
{
      ......
      //  嵌套函数do_add, 使用到了外层函数的变量, 所以co-&gt;co_freevars非空, 这里得到 ('x', )
      if (PyTuple_GET_SIZE(co-&gt;co_freevars)) {
          int i;
          for (i = 0; i &lt; PyTuple_GET_SIZE(co-&gt;co_freevars); ++i) {
              // 顺序是一致的
              PyObject *o = PyTuple_GET_ITEM(closure, i);
              Py_INCREF(o);
              // 放到freevars里面, 编译时已经确定了顺序
              // 在上一步多LOAD_CLOSURE =&gt; tuple 已经保证了顺序
              freevars[PyTuple_GET_SIZE(co-&gt;co_cellvars) + i] = o;
          }
      }
      ......
</pre></div>
<h3 id="dis">最后, 再来看一个闭包的dis</h3>
<p>注意<code>BUILD_TUPLE</code></p>
<div class="codehilite"><pre>def add(x, y):

    def do_add(value):
        return x + value

    def do_add2(value):
        return y + value

    def do_add3(value):
        return x + y + value

    return do_add
</pre></div>
<p>dis结果</p>
<div class="codehilite"><pre> 18           0 LOAD_CLOSURE             0 (x)
              3 BUILD_TUPLE              1
              6 LOAD_CONST               1 (&lt;code object do_add at 0x10560dc30, file "a.py", line 18&gt;)
              9 MAKE_CLOSURE             0
             12 STORE_FAST               2 (do_add)

 21          15 LOAD_CLOSURE             1 (y)
             18 BUILD_TUPLE              1
             21 LOAD_CONST               2 (&lt;code object do_add2 at 0x10560d8b0, file "a.py", line 21&gt;)
             24 MAKE_CLOSURE             0
             27 STORE_FAST               3 (do_add2)

 24          30 LOAD_CLOSURE             0 (x)
             33 LOAD_CLOSURE             1 (y)
             36 BUILD_TUPLE              2
             39 LOAD_CONST               3 (&lt;code object do_add3 at 0x10560e3b0, file "a.py", line 24&gt;)
             42 MAKE_CLOSURE             0
             45 STORE_FAST               4 (do_add3)

 32          48 LOAD_FAST                2 (do_add)
             51 RETURN_VALUE
</pre></div>
    </section>

    <section id="copyright">
        <div class="copyright">
            版权声明：自由转载-非商用-非衍生-保持署名 | <a href="http://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh" target="_blank" >Creative Commons BY-NC-ND 3.0</a>
        </div>

        <div class="donation">
            <center>
            <img src="/imgs/life/donation.png"/>
            <strong> 如果你觉得我的文章或项目对你有所帮助, You can buy me a coffee:) </strong>
            </center>
        </div>
    </section>


    <section id="neighbors">
        <div>
                        <a class="left" href="http://www.wklken.me/posts/2015/08/29/python-source-memory-2.html">
                            上一篇:  Python源码阅读-内存管理机制(二)
                        </a>
                        <a class="right" href="http://www.wklken.me/posts/2015/09/23/apue-note-chapter-1.html">
                            下一篇: APUE笔记-第一章 UNIX基础知识
                        </a>
        </div>
    </section>

<section id="comments">
        <div class="comments">
            <div id="disqus_thread"></div>
            <script type="text/javascript">
                var disqus_identifier = "posts/2015/09/04/python-source-closure.html";
                (function() {
                var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
                dsq.src = 'http://wklken.disqus.com/embed.js';
                (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
                })();
            </script>
            </div>
</section>
</article>
        </section><!--end #main-->

            <footer class="row">
                <div class="large-12 columns">
                    <p>
                            Copyright © 2015 wklken <br>
                            Hosted on <a href="http://www.vultr.com/?ref=6847203"> vultr </a> . Powered by <a href="http://alexis.notmyidea.org/pelican/">pelican</a>. Social Icons by <a href="http://fortawesome.github.io/Font-Awesome/">Font-Awesome</a>.
                    </p>
                </div>
            </footer>

            </div>
        </div>

        <section id="extras" class="body">
        </section><!-- /#extras -->

    <script type="text/javascript">
    var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
    document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
    </script>
    <script type="text/javascript">
    try {
        var pageTracker = _gat._getTracker("UA-42275748-1");
    pageTracker._trackPageview();
    } catch(err) {}</script>



<script src="http://apps.bdimg.com/libs/jquery/2.1.1/jquery.min.js"></script>
<script src="http://apps.bdimg.com/libs/jquery-scrollUp/2.1.0/jquery.scrollUp.min.js"></script>
<script src="http://apps.bdimg.com/libs/jqueryui/1.10.4/jquery-ui.min.js"></script>
<script>
    $(function(){
        $.scrollUp({
              scrollText: '', // Text for element, can contain HTML
            });
    });
</script>


<script type="text/javascript">
  /* var Swiftype = window.Swiftype || {}; */
  /* Swiftype.searchSearchFields = { */
    /* "page": ["title^10", "body"] */
  /* }; */

  /* (function(w,d,t,u,n,s,e){w['SwiftypeObject']=n;w[n]=w[n]||function(){ */
  /* (w[n].q=w[n].q||[]).push(arguments);};s=d.createElement(t); */
  /* e=d.getElementsByTagName(t)[0];s.async=1;s.src=u;e.parentNode.insertBefore(s,e); */
  /* })(window,document,'script','//s.swiftypecdn.com/install/v1/st.js','_st'); */

  /* _st('install','v6K-_DamCeHvwX6z3o2F'); */
</script>

<script src="/theme/js/instantclick.min.js" data-no-instant></script>
<script data-no-instant>InstantClick.init();</script>


<div id="share">
<script>window._bd_share_config={"common":{"bdSnsKey":{},"bdText":"","bdMini":"1","bdMiniList":["mshare","tsina","weixin","douban","meilishuo","mogujie","youdao","sdo","mail","twi","copy","print"],"bdPic":"","bdStyle":"0","bdSize":"16"},"slide":{"type":"slide","bdImg":"5","bdPos":"right","bdTop":"96.5"}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];</script>
</div>



<script  src="http://www.wklken.me/theme/js/scroll-header.js" type="text/javascript"></script>



</body>
</html>