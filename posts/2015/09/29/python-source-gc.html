<!DOCTYPE html>
<html lang="en">

<!--[if IE 8]> <html class="no-js lt-ie9" lang="en"> <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en"> <!--<![endif]-->

<head>
    <meta name="google-site-verification" content="SzE6WCs23qFevgBzRIuG9vcfLU0lW_Vd5hFT-cJOLBE" />
    <title>Python 源码阅读 - 垃圾回收机制</title>
    <meta charset="utf-8" />
    <meta name="description" content="">
    <meta name="keywords" content="" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">

        <link rel="shortcut icon" href="/favicon.ico"/>
        <link rel="stylesheet" href="/theme/css/styles.css" media="all" />
        <link rel="stylesheet" href="/theme/css/tab.min.css" media="all" />
        <link rel="stylesheet" href="/theme/css/jquery-ui.min.css" media="all" />

        <link rel="stylesheet" href="/theme/css/font-awesome.min.css">
        <!--
        <link rel="stylesheet" href="http://apps.bdimg.com/libs/fontawesome/4.2.0/css/font-awesome.min.css">
        -->
        <!--[if IE 7]>
            <link rel="stylesheet" href="/theme/css/font-awesome-ie7.min.css">
        <![endif]-->

        <link href="/" type="application/atom+xml" rel="alternate" title="wklken's blog ATOM Feed" />
        <link href="/feed.xml" type="application/atom+xml" rel="alternate" title="wklken's blog RSS Feed" />

</head>

<body>
    <div id="page" class="row">
        <div class="large-9 large-centered columns">

        <header id="header">
            <div class="constraint">
                <div class="o">
                    <a href="/"><h1 class="banner">Wklken <span class="blue"> Building </span></h1></a>

                <div class="social">
                            <a href="https://github.com/wklken" target='_blank'><i class="icon-github-sign icon-2x"></i></a>
                            <a href="http://weibo.com/wklken" target='_blank'><i class="icon-weibo icon-2x"></i></a>
                            <a href="mailto:wklken@yeah.net"><i class="icon-envelope icon-2x"></i></a>
                            <a href="http://www.wklken.me/feed.xml" target='_blank'><i class="icon-rss-sign icon-2x"></i></a>
                </div>
                <div class="nav">
                            <a href="/">首页</a>
                            <a href="/categories.html">分类</a>
                            <a href="/archives.html">归档</a>
                            <a href="/pages/projects.html">项目</a>
                            <a href="/pages/aboutme.html">关于</a>

                </div>

                </div>
            </div>
        </header><!-- /#banner -->

        <section id="main">


<article id="article">
    <section id="header">
        <!--
        <div class="meta">2015年09月29日</div>
        <h1 id="title"> Python 源码阅读 - 垃圾回收机制 </h1>
        -->
        <div class="meta"> &nbsp; </div>
        <h1> Python 源码阅读 - 垃圾回收机制 </h1>
    </section>

        <section id="toc">
            <div id="toc"><ul><li><a class="toc-href" href="#" title="Python 源码阅读 - 垃圾回收机制">Python 源码阅读 - 垃圾回收机制</a><ul><li><a class="toc-href" href="#_1" title="概述">概述</a></li><li><a class="toc-href" href="#_2" title="引用计数">引用计数</a><ul><li><a class="toc-href" href="#_3" title="计数存储">计数存储</a></li><li><a class="toc-href" href="#_4" title="计数增加">计数增加</a></li><li><a class="toc-href" href="#_5" title="计数减少">计数减少</a></li><li><a class="toc-href" href="#pyobject_del-pyobject_gc_del" title="内存回收 PyObject_Del / PyObject_GC_Del">内存回收 PyObject_Del / PyObject_GC_Del</a></li></ul></li><li><a class="toc-href" href="#-_1" title="标记-清除">标记-清除</a><ul><li><a class="toc-href" href="#_6" title="问题: 什么对象可能产生循环引用?">问题: 什么对象可能产生循环引用?</a></li><li><a class="toc-href" href="#_7" title="可收集对象链表">可收集对象链表</a></li><li><a class="toc-href" href="#pyobject_head-and-pygc_head" title="PyObject_HEAD and PyGC_HEAD">PyObject_HEAD and PyGC_HEAD</a></li><li><a class="toc-href" href="#container" title="问题: 什么时候将container放到这个对象链表中">问题: 什么时候将container放到这个对象链表中</a></li><li><a class="toc-href" href="#container_1" title="问题: 什么时候将container从这个对象链表中摘除">问题: 什么时候将container从这个对象链表中摘除</a></li><li><a class="toc-href" href="#-_2" title="问题: 如何进行标记-清除">问题: 如何进行标记-清除</a><ul><li><a class="toc-href" href="#0" title="0. 概览">0. 概览</a></li><li><a class="toc-href" href="#1-gc_list_merge" title="1. 第一步:  gc_list_merge">1. 第一步:  gc_list_merge</a></li><li><a class="toc-href" href="#2-update_refs" title="2. 第二步: update_refs">2. 第二步: update_refs</a></li><li><a class="toc-href" href="#3" title="3. 第三步: 计算有效引用计数">3. 第三步: 计算有效引用计数</a></li><li><a class="toc-href" href="#4" title="4. 第四步: 垃圾标记">4. 第四步: 垃圾标记</a></li><li><a class="toc-href" href="#5" title="5. 第五步: 将存活对象放入下一代">5. 第五步: 将存活对象放入下一代</a></li><li><a class="toc-href" href="#6" title="6. 第六步: 执行回收">6. 第六步: 执行回收</a></li><li><a class="toc-href" href="#7-gc" title="7. gc逻辑">7. gc逻辑</a></li></ul></li></ul></li><li><a class="toc-href" href="#_10" title="分代回收">分代回收</a><ul><li><a class="toc-href" href="#_11" title="表头数据结构">表头数据结构</a></li><li><a class="toc-href" href="#_12" title="三个代的定义">三个代的定义</a></li><li><a class="toc-href" href="#_13" title="超过阈值, 触发垃圾回收">超过阈值, 触发垃圾回收</a></li></ul></li><li><a class="toc-href" href="#python-gc_1" title="Python 中的gc模块">Python 中的gc模块</a></li></ul></li></ul></div>
        </section>
    <section id="content">
        <h2 id="_1">概述</h2>
<p>无论何种垃圾收集机制, 一般都是两阶段: 垃圾检测和垃圾回收.</p>
<p>在Python中, 大多数对象的生命周期都是通过对象的引用计数来管理的.</p>
<p>问题: 但是存在循环引用的问题: a 引用 b, b 引用 a, 导致每一个对象的引用计数都不为0, 所占用的内存永远不会被回收</p>
<p>要解决循环引用: 必需引入其他垃圾收集技术来打破循环引用. Python中使用了<code>标记-清除</code>以及<code>分代收集</code></p>
<p>即, Python 中垃圾回收机制: 引用计数(主要), 标记清除, 分代收集(辅助)</p>
<h2 id="_2">引用计数</h2>
<p>引用计数, 意味着必须在每次分配和释放内存的时候, 加入管理引用计数的动作</p>
<p>引用计数的优点: 最直观最简单, 实时性, 任何内存, 一旦没有指向它的引用, 就会立即被回收</p>
<h3 id="_3">计数存储</h3>
<p>回顾  <a href="http://www.wklken.me/posts/2014/08/05/python-source-object.html">Python 的对象</a></p>
<p><img alt="" src="http://www.wklken.me/imgs/python-source/PyObject.png"/>￼</p>
<p><img alt="" src="http://www.wklken.me/imgs/python-source/PyVarObject.png"/>￼</p>
<p>e.g. 引用计数增加以及减少</p>
<div class="codehilite"><pre><span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">sys</span> <span class="kn">import</span> <span class="n">getrefcount</span>
<span class="o">&gt;&gt;&gt;</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">a</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">getrefcount</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="mi">2</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">b</span> <span class="o">=</span> <span class="n">a</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">getrefcount</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="mi">3</span>
<span class="o">&gt;&gt;&gt;</span> <span class="k">del</span> <span class="n">b</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">getrefcount</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="mi">2</span>
</pre></div>
<h3 id="_4">计数增加</h3>
<p>增加对象引用计数, refcnt incr</p>
<div class="codehilite"><pre>  #define Py_INCREF(op) (                         \
      _Py_INC_REFTOTAL  _Py_REF_DEBUG_COMMA       \
      ((PyObject*)(op))-&gt;ob_refcnt++)
</pre></div>
<h3 id="_5">计数减少</h3>
<p>减少对象引用计数, refcnt desc</p>
<div class="codehilite"><pre>  #define _Py_DEC_REFTOTAL        _Py_RefTotal--
  #define _Py_REF_DEBUG_COMMA     ,

  #define Py_DECREF(op)                                   \
      do {                                                \
          if (_Py_DEC_REFTOTAL  _Py_REF_DEBUG_COMMA       \
          --((PyObject*)(op))-&gt;ob_refcnt != 0)            \
              _Py_CHECK_REFCNT(op)                        \
          else                                            \
          _Py_Dealloc((PyObject *)(op));                  \
      } while (0)
</pre></div>
<p>即, 发现refcnt变成0的时候, 会调用<code>_Py_Dealloc</code></p>
<div class="codehilite"><pre>  PyAPI_FUNC(void) _Py_Dealloc(PyObject *);
  #define _Py_REF_DEBUG_COMMA     ,

  #define _Py_Dealloc(op) (                               \
      _Py_INC_TPFREES(op) _Py_COUNT_ALLOCS_COMMA          \
      (*Py_TYPE(op)-&gt;tp_dealloc)((PyObject *)(op)))
  #endif /* !Py_TRACE_REFS */
</pre></div>
<p>会调用各自类型的<code>tp_dealloc</code></p>
<p>例如dict</p>
<div class="codehilite"><pre>PyTypeObject PyDict_Type = {
    PyVarObject_HEAD_INIT(&amp;PyType_Type, 0)
    "dict",
    sizeof(PyDictObject),
    0,
    (destructor)dict_dealloc,                   /* tp_dealloc */
    ....
}


static void
dict_dealloc(register PyDictObject *mp)
{
    .....
    // 如果满足条件, 放入到缓冲池freelist中
    if (numfree &lt; PyDict_MAXFREELIST &amp;&amp; Py_TYPE(mp) == &amp;PyDict_Type)
        free_list[numfree++] = mp;
    // 否则, 调用tp_free
    else
        Py_TYPE(mp)-&gt;tp_free((PyObject *)mp);
    Py_TRASHCAN_SAFE_END(mp)
}
</pre></div>
<p>Python基本类型的<code>tp_dealloc</code>, 通常都会与各自的缓冲池机制相关, 释放会优先放入缓冲池中(对应的分配会优先从缓冲池取). 这个内存分配与回收同缓冲池机制相关</p>
<p>当无法放入缓冲池时, 会调用各自类型的<code>tp_free</code></p>
<p>int, 比较特殊</p>
<div class="codehilite"><pre>// int, 通用整数对象缓冲池机制
      (freefunc)int_free,                         /* tp_free */
</pre></div>
<p>string</p>
<div class="codehilite"><pre>// string
    PyObject_Del,                               /* tp_free */
</pre></div>
<p>dict/tuple/list</p>
<div class="codehilite"><pre>    PyObject_GC_Del,                            /* tp_free */
</pre></div>
<p>然后, 我们再回头看, 自定义对象的<code>tp_free</code></p>
<div class="codehilite"><pre>PyTypeObject PyType_Type = {
    PyVarObject_HEAD_INIT(&amp;PyType_Type, 0)
    "type",                                     /* tp_name */
    ...
    PyObject_GC_Del,                            /* tp_free */
};
</pre></div>
<p>即, 最终, 当计数变为0, 触发内存回收动作. 涉及函数<code>PyObject_Del</code>和<code>PyObject_GC_Del</code>, 并且, 自定义类以及容器类型(dict/list/tuple/set等)使用的都是后者<code>PyObject_GC_Del</code>.</p>
<h3 id="pyobject_del-pyobject_gc_del">内存回收 PyObject_Del / PyObject_GC_Del</h3>
<p>如果引用计数=0:</p>
<div class="codehilite"><pre>1. 放入缓冲池
2. 真正销毁, PyObject_Del/PyObject_GC_Del内存操作
</pre></div>
<p>这两个操作都是进行内存级别的操作</p>
<ul>
<li>PyObject_Del</li>
</ul>
<blockquote>
<p>PyObject_Del(op) releases the memory allocated for an object.  It does not
  run a destructor -- it only frees the memory.  PyObject_Free is identical.</p>
</blockquote>
<p>这块删除, <code>PyObject_Free</code> 涉及到了Python底层内存的分配和管理机制, 具体见前面的博文</p>
<ul>
<li>PyObject_GC_Del</li>
</ul>
<div class="codehilite"><pre>  void
  PyObject_GC_Del(void *op)
  {
      PyGC_Head *g = AS_GC(op);

      // Returns true if a given object is tracked
      if (IS_TRACKED(op))
          // 从跟踪链表中移除
          gc_list_remove(g);
      if (generations[0].count &gt; 0) {
          generations[0].count--;
      }
      PyObject_FREE(g);
  }
</pre></div>
<p><code>IS_TRACKED</code> 涉及到标记-清除的机制</p>
<p><code>generations</code> 涉及到了分代回收</p>
<p><code>PyObject_FREE</code>, 则和Python底层内存池机制相关</p>
<h2 id="-_1">标记-清除</h2>
<h3 id="_6">问题: 什么对象可能产生循环引用?</h3>
<p>只需要关注关注可能产生循环引用的对象</p>
<p>PyIntObject/PyStringObject等不可能</p>
<p>Python中的循环引用总是发生在container对象之间, 所谓containser对象即是内部可持有对其他对象的引用: list/dict/class/instance等等</p>
<p>垃圾收集带来的开销依赖于container对象的数量, 必需跟踪所创建的每一个container对象, 并将这些对象组织到一个集合中.</p>
<h3 id="_7">可收集对象链表</h3>
<p>可收集对象链表: 将需要被收集和跟踪的container, 放到可收集的链表中</p>
<p>任何一个python对象都分为两部分: PyObject_HEAD + 对象本身数据</p>
<div class="codehilite"><pre><span class="cm">/* PyObject_HEAD defines the initial segment of every PyObject. */</span><span class="w"></span>
<span class="err">#</span>define<span class="w"> </span>PyObject_HEAD<span class="w">                   </span><span class="o">\</span><span class="w"></span>
<span class="w">    </span>_PyObject_HEAD_EXTRA<span class="w">                </span><span class="o">\</span><span class="w"></span>
<span class="w">    </span>Py_ssize_t<span class="w"> </span>ob_refcnt<span class="err">;</span><span class="w">               </span><span class="o">\</span><span class="w"></span>
<span class="w">    </span>struct<span class="w"> </span>_typeobject<span class="w"> </span><span class="o">*</span>ob_type<span class="err">;</span><span class="w"></span>

<span class="o">//----------------------------------------------------</span><span class="w"></span>

<span class="w">  </span><span class="err">#</span>define<span class="w"> </span>_PyObject_HEAD_EXTRA<span class="w">            </span><span class="o">\</span><span class="w"></span>
<span class="w">      </span>struct<span class="w"> </span>_object<span class="w"> </span><span class="o">*</span>_ob_next<span class="err">;</span><span class="w">           </span><span class="o">\</span><span class="w"></span>
<span class="w">      </span>struct<span class="w"> </span>_object<span class="w"> </span><span class="o">*</span>_ob_prev<span class="err">;</span><span class="w"></span>

<span class="o">//</span><span class="w"> </span><span class="err">双向链表结构</span><span class="o">,</span><span class="w"> </span><span class="err">垃圾回收</span><span class="w"></span>
</pre></div>
<p>可收集对象链表</p>
<div class="codehilite"><pre><span class="n">Modules</span><span class="o">/</span><span class="n">gcmodule</span><span class="p">.</span><span class="n">c</span>

 <span class="o">/*</span> <span class="n">GC</span> <span class="n">information</span> <span class="ow">is</span> <span class="n">stored</span> <span class="n">BEFORE</span> <span class="n">the</span> <span class="kt">object</span> <span class="n">structure</span><span class="p">.</span> <span class="o">*/</span>
  <span class="n">typedef</span> <span class="n">union</span> <span class="n">_gc_head</span> <span class="p">{</span>
      <span class="n">struct</span> <span class="p">{</span>
          <span class="o">//</span> <span class="n">建立链表需要的前后指针</span>
          <span class="n">union</span> <span class="n">_gc_head</span> <span class="o">*</span><span class="n">gc_next</span><span class="err">;</span>
          <span class="n">union</span> <span class="n">_gc_head</span> <span class="o">*</span><span class="n">gc_prev</span><span class="err">;</span>
          <span class="o">//</span> <span class="n">在初始化时会被初始化为</span> <span class="n">GC_UNTRACED</span>
          <span class="n">Py_ssize_t</span> <span class="n">gc_refs</span><span class="err">;</span>
      <span class="p">}</span> <span class="n">gc</span><span class="err">;</span>
      <span class="kt">long</span> <span class="kt">double</span> <span class="n">dummy</span><span class="err">;</span>  <span class="o">/*</span> <span class="n">force</span> <span class="n">worst</span><span class="o">-</span><span class="k">case</span> <span class="n">alignment</span> <span class="o">*/</span>
  <span class="p">}</span> <span class="n">PyGC_Head</span><span class="err">;</span>
</pre></div>
<p>创建container的过程: <code>container对象 = pyGC_Head | PyObject_HEAD | Container Object</code></p>
<div class="codehilite"><pre>PyObject *
_PyObject_GC_New(PyTypeObject *tp)
{
    PyObject *op = _PyObject_GC_Malloc(_PyObject_SIZE(tp));
    if (op != NULL)
        op = PyObject_INIT(op, tp);
    return op;
}

=&gt; _PyObject_GC_Malloc

#define _PyGC_REFS_UNTRACKED                    (-2)
#define GC_UNTRACKED                    _PyGC_REFS_UNTRACKED

PyObject *
_PyObject_GC_Malloc(size_t basicsize)
{
    PyObject *op;
    PyGC_Head *g;
    if (basicsize &gt; PY_SSIZE_T_MAX - sizeof(PyGC_Head))
        return PyErr_NoMemory();

    // 为 对象本身+PyGC_Head申请内存, 注意分配的size
    g = (PyGC_Head *)PyObject_MALLOC(
        sizeof(PyGC_Head) + basicsize);
    if (g == NULL)
        return PyErr_NoMemory();

    // 初始化 GC_UNTRACED
    g-&gt;gc.gc_refs = GC_UNTRACKED;
    generations[0].count++; /* number of allocated GC objects */

    // 如果大于阈值, 执行分代回收
    if (generations[0].count &gt; generations[0].threshold &amp;&amp;
        enabled &amp;&amp;
        generations[0].threshold &amp;&amp;
        !collecting &amp;&amp;
        !PyErr_Occurred()) {

        collecting = 1;
        collect_generations();
        collecting = 0;
    }
    op = FROM_GC(g);
    return op;
}
</pre></div>
<h3 id="pyobject_head-and-pygc_head">PyObject_HEAD and PyGC_HEAD</h3>
<p>注意, <code>FROM_GC</code>和<code>AS_GC</code>用于 <code>PyObject_HEAD &lt;=&gt; PyGC_HEAD</code>地址相互转换</p>
<div class="codehilite"><pre><span class="n">Modules</span><span class="o">/</span><span class="n">gcmodule</span><span class="p">.</span><span class="n">c</span>

 <span class="o">/*</span> <span class="k">Get</span> <span class="n">an</span> <span class="kt">object</span><span class="c">'s GC head */</span>
  <span class="p">#</span><span class="n">define</span> <span class="n">AS_GC</span><span class="p">(</span><span class="n">o</span><span class="p">)</span> <span class="p">((</span><span class="n">PyGC_Head</span> <span class="o">*</span><span class="p">)(</span><span class="n">o</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>

  <span class="o">/*</span> <span class="k">Get</span> <span class="n">the</span> <span class="kt">object</span> <span class="n">given</span> <span class="n">the</span> <span class="n">GC</span> <span class="n">head</span> <span class="o">*/</span>
  <span class="p">#</span><span class="n">define</span> <span class="n">FROM_GC</span><span class="p">(</span><span class="n">g</span><span class="p">)</span> <span class="p">((</span><span class="n">PyObject</span> <span class="o">*</span><span class="p">)(((</span><span class="n">PyGC_Head</span> <span class="o">*</span><span class="p">)</span><span class="n">g</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>

<span class="n">objimpl</span><span class="p">.</span><span class="n">h</span>

<span class="p">#</span><span class="n">define</span> <span class="n">_Py_AS_GC</span><span class="p">(</span><span class="n">o</span><span class="p">)</span> <span class="p">((</span><span class="n">PyGC_Head</span> <span class="o">*</span><span class="p">)(</span><span class="n">o</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
<h3 id="container">问题: 什么时候将container放到这个对象链表中</h3>
<p>e.g list</p>
<div class="codehilite"><pre>listobject.c

PyObject *
PyList_New(Py_ssize_t size)
{
    PyListObject *op;
    op = PyObject_GC_New(PyListObject, &amp;PyList_Type);
    _PyObject_GC_TRACK(op);
    return (PyObject *) op;
}

// =&gt;  _PyObject_GC_TRACK

// objimpl.h
// 加入到可收集对象链表中

#define _PyObject_GC_TRACK(o) do { \
    PyGC_Head *g = _Py_AS_GC(o); \
    if (g-&gt;gc.gc_refs != _PyGC_REFS_UNTRACKED) \
        Py_FatalError("GC object already tracked"); \
    g-&gt;gc.gc_refs = _PyGC_REFS_REACHABLE; \
    g-&gt;gc.gc_next = _PyGC_generation0; \
    g-&gt;gc.gc_prev = _PyGC_generation0-&gt;gc.gc_prev; \
    g-&gt;gc.gc_prev-&gt;gc.gc_next = g; \
    _PyGC_generation0-&gt;gc.gc_prev = g; \
    } while (0);
</pre></div>
<h3 id="container_1">问题: 什么时候将container从这个对象链表中摘除</h3>
<div class="codehilite"><pre>// Objects/listobject.c

static void
list_dealloc(PyListObject *op)
{
    Py_ssize_t i;
    PyObject_GC_UnTrack(op);
    .....
}

// =&gt; PyObject_GC_UnTrack =&gt; _PyObject_GC_UNTRACK

// 对象销毁的时候
#define _PyObject_GC_UNTRACK(o) do { \
    PyGC_Head *g = _Py_AS_GC(o); \
    assert(g-&gt;gc.gc_refs != _PyGC_REFS_UNTRACKED); \
    g-&gt;gc.gc_refs = _PyGC_REFS_UNTRACKED; \
    g-&gt;gc.gc_prev-&gt;gc.gc_next = g-&gt;gc.gc_next; \
    g-&gt;gc.gc_next-&gt;gc.gc_prev = g-&gt;gc.gc_prev; \
    g-&gt;gc.gc_next = NULL; \
    } while (0);
</pre></div>
<h3 id="-_2">问题: 如何进行标记-清除</h3>
<p>现在, 我们得到了一个链表</p>
<p>Python将自己的垃圾收集限制在这个链表上, 循环引用一定发生在这个链表的一群独享之间.</p>
<h4 id="0">0. 概览</h4>
<p><code>_PyObject_GC_Malloc</code> 分配内存时, 发现超过阈值, 此时, 会触发gc, <code>collect_generations</code>
然后调用<code>collect</code>, <code>collect</code>包含标记-清除逻辑</p>
<div class="codehilite"><pre>gcmodule.c

  /* This is the main function.  Read this to understand how the
   * collection process works. */
  static Py_ssize_t
  collect(int generation)
  {
    // 第1步: 将所有比 当前代 年轻的代中的对象 都放到 当前代 的对象链表中
    /* merge younger generations with one we are currently collecting */
    for (i = 0; i &lt; generation; i++) {
        gc_list_merge(GEN_HEAD(i), GEN_HEAD(generation));
    }


    // 第2步
    update_refs(young);
    // 第3步
    subtract_refs(young);

    // 第4步
    gc_list_init(&amp;unreachable);
    move_unreachable(young, &amp;unreachable);

    // 第5步
      /* Move reachable objects to next generation. */
      if (young != old) {
          if (generation == NUM_GENERATIONS - 2) {
              long_lived_pending += gc_list_size(young);
          }
          gc_list_merge(young, old);
      }
      else {
          /* We only untrack dicts in full collections, to avoid quadratic
             dict build-up. See issue #14775. */
          untrack_dicts(young);
          long_lived_pending = 0;
          long_lived_total = gc_list_size(young);
      }

    // 第6步
      delete_garbage(&amp;unreachable, old);

  }
</pre></div>
<h4 id="1-gc_list_merge">1. 第一步:  gc_list_merge</h4>
<p>将所有比 当前代 年轻的代中的对象 都放到 当前代 的对象链表中</p>
<div class="codehilite"><pre>=&gt; gc_list_merge

// 执行拷贝而已
/* append list `from` onto list `to`; `from` becomes an empty list */
static void
gc_list_merge(PyGC_Head *from, PyGC_Head *to)
{
    PyGC_Head *tail;
    assert(from != to);
    if (!gc_list_is_empty(from)) {
        tail = to-&gt;gc.gc_prev;
        tail-&gt;gc.gc_next = from-&gt;gc.gc_next;
        tail-&gt;gc.gc_next-&gt;gc.gc_prev = tail;
        to-&gt;gc.gc_prev = from-&gt;gc.gc_prev;
        to-&gt;gc.gc_prev-&gt;gc.gc_next = to;
    }
    // 清空
    gc_list_init(from);
}

=&gt;

static void
gc_list_init(PyGC_Head *list)
{
    list-&gt;gc.gc_prev = list;
    list-&gt;gc.gc_next = list;
}
</pre></div>
<p>即, 此刻, 所有待进行处理的对象都集中在同一个链表中</p>
<p>处理,</p>
<p>其逻辑是, 要去除循环引用, 得到有效引用计数</p>
<p>有效引用计数: 将循环引用的计数去除, 最终得到的 =&gt; 将环从引用中摘除, 各自引用计数数值-1</p>
<p>实际操作, 并不要直接修改对象的 ob_refcnt, 而是修改其副本, <code>PyGC_Head</code>中的<code>gc.gc_ref</code></p>
<h4 id="2-update_refs">2. 第二步: update_refs</h4>
<p>遍历对象链表, 将每个对象的gc.gc_ref值设置为ob_refcnt</p>
<div class="codehilite"><pre>gcmodule.c

static void
update_refs(PyGC_Head *containers)
{
    PyGC_Head *gc = containers-&gt;gc.gc_next;
    for (; gc != containers; gc = gc-&gt;gc.gc_next) {
        assert(gc-&gt;gc.gc_refs == GC_REACHABLE);
        gc-&gt;gc.gc_refs = Py_REFCNT(FROM_GC(gc));
        /* Python's cyclic gc should never see an incoming refcount
         * of 0:  if something decref'ed to 0, it should have been
         * deallocated immediately at that time.
         * Possible cause (if the assert triggers):  a tp_dealloc
         * routine left a gc-aware object tracked during its teardown
         * phase, and did something-- or allowed something to happen --
         * that called back into Python.  gc can trigger then, and may
         * see the still-tracked dying object.  Before this assert
         * was added, such mistakes went on to allow gc to try to
         * delete the object again.  In a debug build, that caused
         * a mysterious segfault, when _Py_ForgetReference tried
         * to remove the object from the doubly-linked list of all
         * objects a second time.  In a release build, an actual
         * double deallocation occurred, which leads to corruption
         * of the allocator's internal bookkeeping pointers.  That's
         * so serious that maybe this should be a release-build
         * check instead of an assert?
         */
        assert(gc-&gt;gc.gc_refs != 0);
    }
}
</pre></div>
<h4 id="3">3. 第三步: 计算有效引用计数</h4>
<div class="codehilite"><pre>  /* A traversal callback for subtract_refs. */
  static int
  visit_decref(PyObject *op, void *data)
  {
      assert(op != NULL);
      // 判断op指向的对象是否是被垃圾收集监控的, 对象的type对象中有Py_TPFLAGS_HAVE_GC符号
      if (PyObject_IS_GC(op)) {
          PyGC_Head *gc = AS_GC(op);
          /* We're only interested in gc_refs for objects in the
           * generation being collected, which can be recognized
           * because only they have positive gc_refs.
           */
          assert(gc-&gt;gc.gc_refs != 0); /* else refcount was too small */
          if (gc-&gt;gc.gc_refs &gt; 0)
              gc-&gt;gc.gc_refs--;  // -1
      }
      return 0;
  }


  /* Subtract internal references from gc_refs.  After this, gc_refs is &gt;= 0
   * for all objects in containers, and is GC_REACHABLE for all tracked gc
   * objects not in containers.  The ones with gc_refs &gt; 0 are directly
   * reachable from outside containers, and so can't be collected.
   */
  static void
  subtract_refs(PyGC_Head *containers)
  {
      traverseproc traverse;
      PyGC_Head *gc = containers-&gt;gc.gc_next;
      // 遍历链表
      for (; gc != containers; gc=gc-&gt;gc.gc_next) {
          // 与特定的类型相关, 得到类型对应的traverse函数
          traverse = Py_TYPE(FROM_GC(gc))-&gt;tp_traverse;
          // 调用
          (void) traverse(FROM_GC(gc),
                         (visitproc)visit_decref, // 回调形式传入
                         NULL);
      }
  }
</pre></div>
<p>我们可以看看dictobject的traverse函数</p>
<div class="codehilite"><pre>  static int
  dict_traverse(PyObject *op, visitproc visit, void *arg)
  {
      Py_ssize_t i = 0;
      PyObject *pk;
      PyObject *pv;

      // 遍历所有键和值
      while (PyDict_Next(op, &amp;i, &amp;pk, &amp;pv)) {
          Py_VISIT(pk);
          Py_VISIT(pv);
      }
      return 0;
  }
</pre></div>
<p>逻辑大概是: 遍历容器对象里面的所有对象, 通过<code>visit_decref</code>将这些对象的引用计数都-1,</p>
<p>最终, 遍历完链表之后, 整个可收集对象链表中所有container对象之间的循环引用都被去掉了</p>
<h4 id="4">4. 第四步: 垃圾标记</h4>
<p><code>move_unreachable</code>, 将可收集对象链表中, 根据有效引用计数 不等于0(root对象) 和 等于0(非root对象, 垃圾, 可回收), 一分为二</p>
<div class="codehilite"><pre> /* Move the unreachable objects from young to unreachable.  After this,
   * all objects in young have gc_refs = GC_REACHABLE, and all objects in
   * unreachable have gc_refs = GC_TENTATIVELY_UNREACHABLE.  All tracked
   * gc objects not in young or unreachable still have gc_refs = GC_REACHABLE.
   * All objects in young after this are directly or indirectly reachable
   * from outside the original young; and all objects in unreachable are
   * not.
   */
  static void
  move_unreachable(PyGC_Head *young, PyGC_Head *unreachable)
  {
      PyGC_Head *gc = young-&gt;gc.gc_next;

      /* Invariants:  all objects "to the left" of us in young have gc_refs
       * = GC_REACHABLE, and are indeed reachable (directly or indirectly)
       * from outside the young list as it was at entry.  All other objects
       * from the original young "to the left" of us are in unreachable now,
       * and have gc_refs = GC_TENTATIVELY_UNREACHABLE.  All objects to the
       * left of us in 'young' now have been scanned, and no objects here
       * or to the right have been scanned yet.
       */

      while (gc != young) {
          PyGC_Head *next;

          // 对于root object,
          if (gc-&gt;gc.gc_refs) {
              /* gc is definitely reachable from outside the
               * original 'young'.  Mark it as such, and traverse
               * its pointers to find any other objects that may
               * be directly reachable from it.  Note that the
               * call to tp_traverse may append objects to young,
               * so we have to wait until it returns to determine
               * the next object to visit.
               */
              PyObject *op = FROM_GC(gc);
              traverseproc traverse = Py_TYPE(op)-&gt;tp_traverse;
              assert(gc-&gt;gc.gc_refs &gt; 0);
              // 设置其gc-&gt;gc.gc_refs = GC_REACHABLE
              gc-&gt;gc.gc_refs = GC_REACHABLE;

              // 注意这里逻辑, visit_reachable, 意图是?
              (void) traverse(op,
                              (visitproc)visit_reachable,
                              (void *)young);
              next = gc-&gt;gc.gc_next;
              if (PyTuple_CheckExact(op)) {
                  _PyTuple_MaybeUntrack(op);
              }
          }
          // 有效引用计数=0, 非root对象, 移动到unreachable链表中
          else {
              /* This *may* be unreachable.  To make progress,
               * assume it is.  gc isn't directly reachable from
               * any object we've already traversed, but may be
               * reachable from an object we haven't gotten to yet.
               * visit_reachable will eventually move gc back into
               * young if that's so, and we'll see it again.
               */
              next = gc-&gt;gc.gc_next;
              gc_list_move(gc, unreachable);
              gc-&gt;gc.gc_refs = GC_TENTATIVELY_UNREACHABLE;
          }
          gc = next;
      }
  }
</pre></div>
<h4 id="5">5. 第五步: 将存活对象放入下一代</h4>
<div class="codehilite"><pre>      /* Move reachable objects to next generation. */
      if (young != old) {
          if (generation == NUM_GENERATIONS - 2) {
              long_lived_pending += gc_list_size(young);
          }
          gc_list_merge(young, old);
      }
      else {
          /* We only untrack dicts in full collections, to avoid quadratic
             dict build-up. See issue #14775. */
          untrack_dicts(young);
          long_lived_pending = 0;
          long_lived_total = gc_list_size(young);
      }
</pre></div>
<h4 id="6">6. 第六步: 执行回收</h4>
<div class="codehilite"><pre>gcmoudle.c

  static int
  gc_list_is_empty(PyGC_Head *list)
  {
      return (list-&gt;gc.gc_next == list);
  }


  /* Break reference cycles by clearing the containers involved.  This is
   * tricky business as the lists can be changing and we don't know which
   * objects may be freed.  It is possible I screwed something up here.
   */
  static void
  delete_garbage(PyGC_Head *collectable, PyGC_Head *old)
  {
      inquiry clear;

      // 遍历
      while (!gc_list_is_empty(collectable)) {
          PyGC_Head *gc = collectable-&gt;gc.gc_next;
          // 得到对象
          PyObject *op = FROM_GC(gc);

          assert(IS_TENTATIVELY_UNREACHABLE(op));
          if (debug &amp; DEBUG_SAVEALL) {
              PyList_Append(garbage, op);
          }
          else {
              // 清引用
              if ((clear = Py_TYPE(op)-&gt;tp_clear) != NULL) {
                  Py_INCREF(op);
                  // 这个操作会调整container对象中每个引用所有对象的引用计数, 从而完成打破循环的最终目标
                  clear(op);
                  Py_DECREF(op);
              }
          }

          // 重新送回到reachable链表.
          // 原因: 在进行clear动作, 如果成功, 会把自己从垃圾收集机制维护的链表中摘除, 由于某些原因, 对象可能在clear的时候, 没有成功完成必要动作, 还不能被销毁, 所以放回去
          if (collectable-&gt;gc.gc_next == gc) {
              /* object is still alive, move it, it may die later */
              gc_list_move(gc, old);
              gc-&gt;gc.gc_refs = GC_REACHABLE;
          }
      }
  }

=&gt; 来看下, list的clear

static int
list_clear(PyListObject *a)
{
    Py_ssize_t i;
    PyObject **item = a-&gt;ob_item;
    if (item != NULL) {
        /* Because XDECREF can recursively invoke operations on
           this list, we make it empty first. */
        i = Py_SIZE(a);
        Py_SIZE(a) = 0;
        a-&gt;ob_item = NULL;
        a-&gt;allocated = 0;
        while (--i &gt;= 0) {
            // 减引用
            Py_XDECREF(item[i]);
        }
        PyMem_FREE(item);
    }
    /* Never fails; the return value can be ignored.
       Note that there is no guarantee that the list is actually empty
       at this point, because XDECREF may have populated it again! */
    return 0;
}


// e.g. 处理list3, 调用其list_clear, 减少list4的引用计数, list4.ob_refcnt=0, 引发对象销毁, 调用list4的list_dealloc


static void
list_dealloc(PyListObject *op)
{
    Py_ssize_t i;
    PyObject_GC_UnTrack(op);  //  从可收集对象链表中去除, 会影响到list4所引用所有对象的引用计数, =&gt; list3.refcnt=0, list3的销毁动作也被触发

    Py_TRASHCAN_SAFE_BEGIN(op)
    if (op-&gt;ob_item != NULL) {
        /* Do it backwards, for Christian Tismer.
           There's a simple test case where somehow this reduces
           thrashing when a *very* large list is created and
           immediately deleted. */
        i = Py_SIZE(op);
        while (--i &gt;= 0) {
            Py_XDECREF(op-&gt;ob_item[i]);
        }
        PyMem_FREE(op-&gt;ob_item);
    }
    if (numfree &lt; PyList_MAXFREELIST &amp;&amp; PyList_CheckExact(op))
        free_list[numfree++] = op;
    else
        Py_TYPE(op)-&gt;tp_free((PyObject *)op);
    Py_TRASHCAN_SAFE_END(op)
}
</pre></div>
<h4 id="7-gc">7. gc逻辑</h4>
<div class="codehilite"><pre>分配内存
-&gt; 发现超过阈值了
-&gt; 触发垃圾回收
-&gt; 将所有可收集对象链表放到一起
-&gt; 遍历, 计算有效引用计数
-&gt; 分成 有效引用计数=0 和 有效引用计数 &gt; 0 两个集合
-&gt; 大于0的, 放入到更老一代
-&gt; =0的, 执行回收
-&gt; 回收遍历容器内的各个元素, 减掉对应元素引用计数(破掉循环引用)
-&gt; 执行-1的逻辑, 若发现对象引用计数=0, 触发内存回收
-&gt; python底层内存管理机制回收内存
</pre></div>
<h2 id="_10">分代回收</h2>
<p>分代收集: 以空间换时间</p>
<p>思想: 将系统中的所有内存块根据其存货的时间划分为不同的集合, 每个集合就成为一个"代", 垃圾收集的频率随着"代"的存活时间的增大而减小(活得越长的对象, 就越不可能是垃圾, 就应该减少去收集的频率)</p>
<p>Python中, 引入了分代收集, 总共三个"代". Python 中, 一个代就是一个链表, 所有属于同一"代"的内存块都链接在同一个链表中</p>
<h3 id="_11">表头数据结构</h3>
<div class="codehilite"><pre>gcmodule.c


  struct gc_generation {
      PyGC_Head head;
      int threshold; /* collection threshold */  // 阈值
      int count; /* count of allocations or collections of younger
                    generations */    // 实时个数
  };
</pre></div>
<h3 id="_12">三个代的定义</h3>
<div class="codehilite"><pre><span class="x">  #define NUM_GENERATIONS 3</span>
<span class="x">  #define GEN_HEAD(n) (&amp;generations[n].head)</span>

<span class="x">  //  三代都放到这个数组中</span>
<span class="x">  /* linked lists of container objects */</span>
<span class="x">  static struct gc_generation generations[NUM_GENERATIONS] = {</span>
<span class="x">      /* PyGC_Head,                               threshold,      count */</span>
<span class="x">      </span><span class="cp">{{</span><span class="o">{</span><span class="nv">GEN_HEAD</span><span class="o">(</span><span class="m">0</span><span class="o">),</span> <span class="nv">GEN_HEAD</span><span class="o">(</span><span class="m">0</span><span class="o">),</span> <span class="m">0</span><span class="cp">}}</span><span class="x">,           700,            0},    //700个container, 超过立即触发垃圾回收机制</span>
<span class="x">      </span><span class="cp">{{</span><span class="o">{</span><span class="nv">GEN_HEAD</span><span class="o">(</span><span class="m">1</span><span class="o">),</span> <span class="nv">GEN_HEAD</span><span class="o">(</span><span class="m">1</span><span class="o">),</span> <span class="m">0</span><span class="cp">}}</span><span class="x">,           10,             0},    // 10个</span>
<span class="x">      </span><span class="cp">{{</span><span class="o">{</span><span class="nv">GEN_HEAD</span><span class="o">(</span><span class="m">2</span><span class="o">),</span> <span class="nv">GEN_HEAD</span><span class="o">(</span><span class="m">2</span><span class="o">),</span> <span class="m">0</span><span class="cp">}}</span><span class="x">,           10,             0},    // 10个</span>
<span class="x">  };</span>

<span class="x">  PyGC_Head *_PyGC_generation0 = GEN_HEAD(0);</span>
</pre></div>
<h3 id="_13">超过阈值, 触发垃圾回收</h3>
<div class="codehilite"><pre> PyObject *
  _PyObject_GC_Malloc(size_t basicsize)
  {
      // 执行分配
      ....
      generations[0].count++; /* number of allocated GC objects */  //增加一个
      if (generations[0].count &gt; generations[0].threshold &amp;&amp; // 发现大于预支了
          enabled &amp;&amp;
          generations[0].threshold &amp;&amp;
          !collecting &amp;&amp;
          !PyErr_Occurred())
          {
              collecting = 1;
              collect_generations();  //  执行收集
              collecting = 0;
          }
      op = FROM_GC(g);
      return op;
  }

=&gt; collect_generations

  static Py_ssize_t
  collect_generations(void)
  {
      int i;
      Py_ssize_t n = 0;

      /* Find the oldest generation (highest numbered) where the count
       * exceeds the threshold.  Objects in the that generation and
       * generations younger than it will be collected. */

      // 从最老的一代, 开始回收
      for (i = NUM_GENERATIONS-1; i &gt;= 0; i--) {  // 遍历所有generation
          if (generations[i].count &gt; generations[i].threshold) {  // 如果超过了阈值
              /* Avoid quadratic performance degradation in number
                 of tracked objects. See comments at the beginning
                 of this file, and issue #4074.
              */
              if (i == NUM_GENERATIONS - 1
                  &amp;&amp; long_lived_pending &lt; long_lived_total / 4)
                  continue;
              n = collect(i); // 执行收集
              break;  // notice: break了
          }
      }
      return n;
  }
</pre></div>
<h2 id="python-gc_1">Python 中的gc模块</h2>
<p>gc模块, 提供了观察和手动使用gc的接口</p>
<div class="codehilite"><pre><span class="kn">import</span> <span class="nn">gc</span>

<span class="n">gc</span><span class="o">.</span><span class="n">set_debug</span><span class="p">(</span><span class="n">gc</span><span class="o">.</span><span class="n">DEBUG_STATS</span> <span class="o">|</span> <span class="n">gc</span><span class="o">.</span><span class="n">DEBUG_LEAK</span><span class="p">)</span>

<span class="n">gc</span><span class="o">.</span><span class="n">collect</span><span class="p">()</span>
</pre></div>
<p>注意<code>__del__</code>给gc带来的影响</p>
    </section>

    <section id="copyright">
        <div class="copyright">
            版权声明：自由转载-非商用-非衍生-保持署名 | <a href="http://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh" target="_blank" >Creative Commons BY-NC-ND 3.0</a>
        </div>

        <div class="donation">
            <center>
            <img src="/imgs/life/donation.png"/>
            <strong> 如果你觉得我的文章或项目对你有所帮助, 可小额捐赠 ¥0.99/¥2.99/¥4.99/¥9.9 用于站点域名及主机维护:)</strong>
            </center>
        </div>
    </section>


    <section id="neighbors">
        <div>
                        <a class="left" href="http://www.wklken.me/posts/2015/09/26/why-i-keep-blogging.html">
                            上一篇:  我为什么要写博客
                        </a>
                        <a class="right" href="http://www.wklken.me/posts/2015/11/08/summary-13-some-points.html">
                            下一篇: 这段时间的一些想法
                        </a>
        </div>
    </section>

    <section id="ad">
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <!-- blog_ad_001 -->
        <ins class="adsbygoogle"
            style="display:block"
            data-ad-client="ca-pub-7635941258020589"
            data-ad-slot="3455159758"
            data-ad-format="auto"></ins>
        <script>
        (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
    </section>



<section id="comments">
        <div class="comments">
            <div id="disqus_thread"></div>
            <script type="text/javascript">
                var disqus_identifier = "posts/2015/09/29/python-source-gc.html";
                (function() {
                var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
                dsq.src = 'http://wklken.disqus.com/embed.js';
                (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
                })();
            </script>
            </div>
</section>



</article>
        </section><!--end #main-->

            <footer class="row">
                <div class="large-12 columns">
                    <p>
                            Copyright © 2015 wklken <br>
                            Hosted on <a href="http://www.vultr.com/?ref=6847203"> vultr </a> Also <a href="https://www.digitalocean.com/?refcode=8ee73f2c47ce"> DigitalOcean </a>. Powered by <a href="http://alexis.notmyidea.org/pelican/">pelican</a>. Social Icons by <a href="http://fortawesome.github.io/Font-Awesome/">Font-Awesome</a>.
                    </p>
                </div>
            </footer>

            </div>
        </div>

        <section id="extras" class="body">
        </section><!-- /#extras -->



<script src="http://apps.bdimg.com/libs/jquery/2.1.1/jquery.min.js"></script>
<script src="http://apps.bdimg.com/libs/jquery-scrollUp/2.1.0/jquery.scrollUp.min.js"></script>
<script src="http://apps.bdimg.com/libs/jqueryui/1.10.4/jquery-ui.min.js"></script>
<script>
    $(function(){
        $.scrollUp({
              scrollText: '', // Text for element, can contain HTML
            });
    });
</script>


<script type="text/javascript">
  /* var Swiftype = window.Swiftype || {}; */
  /* Swiftype.searchSearchFields = { */
    /* "page": ["title^10", "body"] */
  /* }; */

  /* (function(w,d,t,u,n,s,e){w['SwiftypeObject']=n;w[n]=w[n]||function(){ */
  /* (w[n].q=w[n].q||[]).push(arguments);};s=d.createElement(t); */
  /* e=d.getElementsByTagName(t)[0];s.async=1;s.src=u;e.parentNode.insertBefore(s,e); */
  /* })(window,document,'script','//s.swiftypecdn.com/install/v1/st.js','_st'); */

  /* _st('install','v6K-_DamCeHvwX6z3o2F'); */
</script>



    <script type="text/javascript">
    var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
    document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
    </script>
    <script type="text/javascript">
    try {
        var pageTracker = _gat._getTracker("UA-42275748-1");
    pageTracker._trackPageview();
    } catch(err) {}</script>




<div id="share">
<script>window._bd_share_config={"common":{"bdSnsKey":{},"bdText":"","bdMini":"1","bdMiniList":["mshare","tsina","weixin","douban","meilishuo","mogujie","youdao","sdo","mail","twi","copy","print"],"bdPic":"","bdStyle":"0","bdSize":"16"},"slide":{"type":"slide","bdImg":"5","bdPos":"right","bdTop":"96.5"}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];</script>
</div>



<script  src="http://www.wklken.me/theme/js/scroll-header.js" type="text/javascript"></script>




</body>
</html>